<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SHADOW NET | Secure P2P & Firebase Chat</title>
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjQiIGhlaWdodD0iNjQiIHZpZXdCb3g9IjAgMCA2NCA2NCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjY0IiBoZWlnaHQ9IjY0IiBmaWxsPSIjMGEwYTBhIi8+CjxjaXJjbGUgY3g9IjMyIiBjeT0iMjQiIHI9IjgiIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwZmY0MSIgc3Ryb2tlLXdpZHRoPSIyIi8+CjxjaXJjbGUgY3g9IjMyIiBjeT0iMjQiIHI9IjMiIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwZjdmZiIgc3Ryb2tlLXdpZHRoPSIxLjUiLz4KPHBhdGggZD0iTTE2IDQwQzE2IDM2IDIwIDMyIDMyIDMyczE2IDQgMTYgOHY4SDE2VjQwWiIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDBmZjQxIiBzdHJva2Utd2lkdGg9IjIiLz4KPGxpbmUgeDE9IjIwIiB5MT0iNTAiIHgyPSI0NCIgeTI9IjUwIiBzdHJva2U9IiMwMGZmNDEiIHN0cm9rZS13aWR0aD0iIi8+CjxsaW5lIHgxPSIyNCIgeTE9IjU0IiB4Mj0iNDAiIHkyPSI1NCIgc3Ryb2tlPSIjMDBmZjQxIiBzdHJva2Utd2lkdGg9IjIiLz4KPC9zdmc+Cg==">
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;600;700&family=Rajdhani:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
    <style>
        :root {
            --neon-green: #00ff41;
            --neon-blue: #00f7ff;
            --neon-purple: #bd00ff;
            --neon-cyan: #00ffd5;
            --dark-bg: #0a0a0a;
            --terminal-bg: #0d0d0d;
            --text-primary: #e0e0e0;
            --text-secondary: #8a8a8a;
            --success: #00ff41;
            --error: #ff003c;
            --xmas-red: #ff003c;
            --xmas-green: #00ff41;
            --xmas-gold: #ffd700;
            --xmas-silver: #c0c0c0;
            --xmas-blue: #1e90ff;
            --p2p-color: #00ffff;
            --firebase-color: #ff6b00;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        body {
            font-family: 'JetBrains Mono', monospace;
            background: var(--dark-bg);
            color: var(--text-primary);
            min-height: 100vh;
            overflow-x: hidden;
            -webkit-overflow-scrolling: touch;
            position: relative;
        }

        #xmasCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            opacity: 0.3;
        }

        .xmas-field {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 10% 90%, rgba(255, 0, 60, 0.03) 0%, transparent 50%),
                radial-gradient(circle at 90% 10%, rgba(0, 255, 65, 0.03) 0%, transparent 50%);
            z-index: -2;
            animation: xmasPulse 15s ease-in-out infinite;
        }

        @keyframes xmasPulse {
            0%, 100% { opacity: 0.2; transform: scale(1); }
            50% { opacity: 0.4; transform: scale(1.02); }
        }

        .holiday-grid {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                linear-gradient(rgba(255, 0, 60, 0.02) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 255, 65, 0.02) 1px, transparent 1px);
            background-size: 40px 40px;
            z-index: -2;
            animation: gridTwinkle 20s ease-in-out infinite;
        }

        @keyframes gridTwinkle {
            0%, 100% { opacity: 0.1; }
            50% { opacity: 0.25; }
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
            padding: 1rem;
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            z-index: 2;
        }

        .terminal {
            background: linear-gradient(135deg, rgba(13, 13, 13, 0.95), rgba(20, 10, 10, 0.9));
            border: 1px solid rgba(255, 0, 60, 0.2);
            width: 100%;
            max-width: 800px;
            box-shadow: 
                0 0 60px rgba(255, 0, 60, 0.15),
                0 0 100px rgba(0, 255, 65, 0.08),
                inset 0 0 40px rgba(255, 215, 0, 0.03);
            position: relative;
            overflow: hidden;
            transition: all 0.4s ease;
            border-radius: 8px;
        }

        .terminal:hover {
            box-shadow: 
                0 0 80px rgba(255, 0, 60, 0.2),
                0 0 120px rgba(0, 255, 65, 0.1),
                inset 0 0 60px rgba(255, 215, 0, 0.05);
        }

        .terminal::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, var(--xmas-red), var(--xmas-green), transparent);
            animation: terminalGlow 3s ease-in-out infinite;
        }

        @keyframes terminalGlow {
            0%, 100% { opacity: 0.2; }
            50% { opacity: 0.6; }
        }

        .terminal-header {
            background: linear-gradient(135deg, rgba(10, 0, 0, 0.9), rgba(20, 5, 5, 0.95));
            padding: 1rem;
            border-bottom: 1px solid rgba(255, 0, 60, 0.15);
            display: flex;
            flex-direction: column;
            gap: 0.8rem;
            position: relative;
            overflow: hidden;
        }

        .terminal-header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, var(--xmas-red), var(--xmas-green), transparent);
            animation: headerScan 4s linear infinite;
        }

        @keyframes headerScan {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        .terminal-title {
            font-family: 'Rajdhani', sans-serif;
            font-size: 1.2rem;
            font-weight: 700;
            color: transparent;
            background: linear-gradient(45deg, var(--xmas-red), var(--xmas-gold), var(--xmas-green));
            -webkit-background-clip: text;
            background-clip: text;
            letter-spacing: 3px;
            text-align: center;
            text-shadow: 0 0 20px rgba(255, 0, 60, 0.3);
        }

        .terminal-status {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 1rem;
            flex-wrap: wrap;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 0.6rem;
            font-size: 0.75rem;
            padding: 0.4rem 0.8rem;
            background: rgba(0, 255, 65, 0.05);
            border: 1px solid rgba(0, 255, 65, 0.15);
            border-radius: 20px;
            transition: all 0.3s ease;
        }

        .status-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: var(--success);
            animation: pulse 3s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.6; transform: scale(1.1); }
        }

        .terminal-body {
            padding: 1.5rem;
            position: relative;
            display: flex;
            flex-direction: column;
            min-height: 400px;
        }

        .mode-selector {
            text-align: center;
            margin-bottom: 1.5rem;
        }

        .mode-title {
            font-family: 'Rajdhani', sans-serif;
            font-size: 1.5rem;
            font-weight: 800;
            color: transparent;
            background: linear-gradient(45deg, var(--p2p-color), var(--firebase-color));
            -webkit-background-clip: text;
            background-clip: text;
            margin-bottom: 1rem;
            letter-spacing: 2px;
        }

        .mode-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            margin-top: 1rem;
        }

        .mode-btn {
            padding: 1.2rem;
            border: 2px solid;
            background: rgba(10, 0, 0, 0.8);
            color: white;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            border-radius: 8px;
            position: relative;
            overflow: hidden;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .mode-btn.p2p {
            border-color: var(--p2p-color);
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.1), rgba(10, 0, 0, 0.9));
        }

        .mode-btn.firebase {
            border-color: var(--firebase-color);
            background: linear-gradient(135deg, rgba(255, 107, 0, 0.1), rgba(10, 0, 0, 0.9));
        }

        .mode-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
        }

        .mode-btn:active {
            transform: translateY(0);
        }

        .mode-icon {
            font-size: 2rem;
            margin-bottom: 0.5rem;
        }

        .mode-desc {
            font-size: 0.7rem;
            opacity: 0.8;
            margin-top: 0.5rem;
            line-height: 1.2;
        }

        .access-screen {
            text-align: center;
            position: relative;
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            gap: 1rem;
        }

        .logo {
            font-family: 'Rajdhani', sans-serif;
            font-size: 2.2rem;
            font-weight: 800;
            color: transparent;
            background: linear-gradient(45deg, var(--xmas-red), var(--xmas-gold), var(--xmas-green), var(--xmas-blue));
            -webkit-background-clip: text;
            background-clip: text;
            letter-spacing: 4px;
            text-shadow: 
                0 0 20px rgba(255, 0, 60, 0.4),
                0 0 40px rgba(0, 255, 65, 0.2);
            position: relative;
        }

        .logo::after {
            content: '‚ùÑ';
            position: absolute;
            top: -10px;
            right: -20px;
            font-size: 1.5rem;
            animation: snowflakeSpin 8s linear infinite;
            opacity: 0.7;
        }

        @keyframes snowflakeSpin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .tagline {
            font-size: 0.85rem;
            color: var(--xmas-green);
            letter-spacing: 2px;
            text-transform: uppercase;
            position: relative;
            display: inline-block;
            animation: taglineGlow 4s ease-in-out infinite;
        }

        @keyframes taglineGlow {
            0%, 100% { 
                opacity: 1;
                filter: hue-rotate(0deg);
            }
            50% { 
                opacity: 0.8;
                filter: hue-rotate(180deg);
            }
        }

        .tagline::after {
            content: '';
            position: absolute;
            bottom: -8px;
            left: 25%;
            width: 50%;
            height: 1px;
            background: linear-gradient(90deg, transparent, var(--xmas-red), var(--xmas-green), transparent);
        }

        .access-code {
            background: linear-gradient(135deg, rgba(10, 0, 0, 0.7), rgba(20, 5, 5, 0.8));
            border: 1px solid rgba(255, 0, 60, 0.2);
            padding: 1.2rem;
            border-radius: 8px;
            position: relative;
            overflow: hidden;
            margin-bottom: 1.2rem;
            border-left: 3px solid var(--xmas-green);
            border-right: 3px solid var(--xmas-red);
        }

        .access-code::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(45deg, transparent 30%, rgba(0, 255, 65, 0.02) 50%, transparent 70%);
            animation: codeShine 8s linear infinite;
        }

        @keyframes codeShine {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        .code-display {
            font-size: 1.8rem;
            font-weight: 800;
            letter-spacing: 6px;
            color: var(--xmas-gold);
            margin: 0.8rem 0;
            font-family: 'JetBrains Mono', monospace;
            text-shadow: 0 0 15px rgba(255, 215, 0, 0.5);
            position: relative;
            padding: 0.5rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
        }

        .input-group {
            margin-bottom: 0.5rem;
            text-align: left;
            position: relative;
        }

        .input-label {
            display: block;
            margin-bottom: 0.3rem;
            color: var(--text-secondary);
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: 600;
        }

        .terminal-input {
            width: 100%;
            padding: 0.9rem;
            background: linear-gradient(135deg, rgba(10, 0, 0, 0.8), rgba(20, 5, 5, 0.9));
            border: 1px solid rgba(255, 0, 60, 0.2);
            color: var(--xmas-green);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.95rem;
            transition: all 0.3s ease;
            border-radius: 6px;
            -webkit-appearance: none;
        }

        .terminal-input:focus {
            outline: none;
            border-color: var(--xmas-green);
            box-shadow: 0 0 20px rgba(0, 255, 65, 0.2);
            background: linear-gradient(135deg, rgba(10, 0, 0, 0.9), rgba(20, 10, 10, 0.95));
        }

        .terminal-input::placeholder {
            color: rgba(255, 0, 60, 0.3);
        }

        .btn-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.8rem;
            margin-top: 0.5rem;
        }

        .btn-group-full-width {
            grid-column: 1 / -1;
        }

        .terminal-btn {
            padding: 0.9rem;
            border: 1px solid rgba(255, 0, 60, 0.2);
            background: linear-gradient(135deg, rgba(10, 0, 0, 0.8), rgba(20, 5, 5, 0.9));
            color: var(--xmas-green);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            position: relative;
            overflow: hidden;
            border-radius: 6px;
            user-select: none;
            -webkit-user-select: none;
            min-height: 45px;
            touch-action: manipulation;
        }

        .terminal-btn:active {
            transform: scale(0.98);
        }

        .terminal-btn.primary {
            background: linear-gradient(135deg, rgba(255, 0, 60, 0.12), rgba(0, 255, 65, 0.08));
            border-color: var(--xmas-green);
            color: var(--xmas-green);
            position: relative;
            overflow: hidden;
        }

        .terminal-btn.primary::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 215, 0, 0.2), transparent);
            transition: left 0.5s ease;
        }

        .terminal-btn.primary:hover::before {
            left: 100%;
        }

        .terminal-btn.danger {
            background: linear-gradient(135deg, rgba(255, 0, 60, 0.12), rgba(255, 0, 60, 0.08));
            border-color: var(--error);
            color: var(--error);
        }

        .chat-container {
            display: none;
            flex-direction: column;
            height: 60vh;
            position: relative;
            min-height: 450px;
        }

        .chat-header {
            background: linear-gradient(135deg, rgba(10, 0, 0, 0.9), rgba(20, 5, 5, 0.95));
            padding: 1rem;
            border-bottom: 1px solid rgba(255, 0, 60, 0.15);
            position: relative;
            flex-shrink: 0;
        }

        .chat-header::before {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, var(--xmas-red), var(--xmas-green), transparent);
            animation: headerScan 4s linear infinite;
        }

        .chat-info {
            display: flex;
            flex-direction: column;
            gap: 0.8rem;
        }

        .room-code {
            font-size: 1rem;
            color: var(--xmas-gold);
            letter-spacing: 2px;
            text-align: center;
            font-weight: 700;
            position: relative;
            padding: 0.3rem;
        }

        .room-code::before {
            content: 'üîí';
            position: absolute;
            left: -25px;
            top: 50%;
            transform: translateY(-50%);
        }

        .room-code::after {
            content: 'üîí';
            position: absolute;
            right: -25px;
            top: 50%;
            transform: translateY(-50%);
        }

        .connection-mode {
            font-size: 0.7rem;
            padding: 0.3rem 0.6rem;
            border-radius: 15px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            display: inline-block;
            margin-left: 0.5rem;
        }

        .connection-mode.p2p {
            background: rgba(0, 255, 255, 0.2);
            color: var(--p2p-color);
            border: 1px solid var(--p2p-color);
        }

        .connection-mode.firebase {
            background: rgba(255, 107, 0, 0.2);
            color: var(--firebase-color);
            border: 1px solid var(--firebase-color);
        }

        .chat-messages {
            flex: 1;
            padding: 1rem;
            overflow-y: auto;
            background: linear-gradient(135deg, rgba(10, 0, 0, 0.4), rgba(20, 10, 10, 0.6));
            display: flex;
            flex-direction: column;
            gap: 0.8rem;
            min-height: 200px;
            -webkit-overflow-scrolling: touch;
            position: relative;
        }

        .chat-messages::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                repeating-linear-gradient(0deg, 
                    transparent 0px, 
                    transparent 1px, 
                    rgba(255, 215, 0, 0.02) 1px, 
                    rgba(255, 215, 0, 0.02) 2px
                );
            pointer-events: none;
            z-index: -1;
        }

        .message {
            padding: 0.7rem;
            border-left: 2px solid rgba(0, 255, 65, 0.4);
            background: linear-gradient(135deg, rgba(10, 0, 0, 0.7), rgba(20, 10, 10, 0.8));
            animation: messageSlide 0.3s ease-out;
            word-break: break-word;
            border-radius: 0 6px 6px 0;
            font-size: 0.8rem;
            position: relative;
        }

        @keyframes messageSlide {
            from { opacity: 0; transform: translateX(-20px); }
            to { opacity: 1; transform: translateX(0); }
        }

        .message.outgoing {
            border-left-color: var(--xmas-blue);
            background: linear-gradient(135deg, rgba(30, 144, 255, 0.1), rgba(20, 10, 10, 0.8));
        }

        .message.incoming {
            border-left-color: var(--xmas-red);
            background: linear-gradient(135deg, rgba(255, 0, 60, 0.1), rgba(20, 10, 10, 0.8));
        }

        .message.system {
            border-left-color: var(--xmas-gold);
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.08), rgba(20, 10, 10, 0.8));
        }

        .message-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.3rem;
            flex-wrap: wrap;
            gap: 0.3rem;
        }

        .message-sender {
            font-weight: 700;
            color: var(--xmas-green);
            font-size: 0.75rem;
        }

        .message-content {
            font-size: 0.75rem;
            line-height: 1.3;
            color: var(--text-primary);
        }

        .decrypting-text {
            position: relative;
        }

        .decrypting-char {
            display: inline-block;
            color: var(--xmas-gold);
            animation: charDecrypt 0.1s ease-out forwards;
        }

        @keyframes charDecrypt {
            to {
                color: var(--text-primary);
            }
        }

        .chat-input-container {
            background: linear-gradient(135deg, rgba(10, 0, 0, 0.9), rgba(20, 5, 5, 0.95));
            padding: 1rem;
            border-top: 1px solid rgba(255, 0, 60, 0.15);
            position: relative;
            flex-shrink: 0;
        }

        .chat-input-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, var(--xmas-red), var(--xmas-green), transparent);
            animation: headerScan 4s linear infinite;
        }

        .chat-input-group {
            display: flex;
            flex-direction: column;
            gap: 0.8rem;
        }

        .chat-input {
            flex: 1;
            padding: 0.8rem;
            background: linear-gradient(135deg, rgba(10, 0, 0, 0.8), rgba(20, 5, 5, 0.9));
            border: 1px solid rgba(255, 0, 60, 0.2);
            color: var(--xmas-green);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            border-radius: 6px;
            transition: all 0.3s ease;
            -webkit-appearance: none;
            min-height: 40px;
        }

        .chat-input:focus {
            outline: none;
            border-color: var(--xmas-green);
            box-shadow: 0 0 20px rgba(0, 255, 65, 0.2);
            background: linear-gradient(135deg, rgba(10, 0, 0, 0.9), rgba(20, 10, 10, 0.95));
        }

        .send-btn {
            padding: 0.8rem;
            background: linear-gradient(135deg, rgba(255, 0, 60, 0.12), rgba(0, 255, 65, 0.08));
            border: 1px solid var(--xmas-green);
            color: var(--xmas-green);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            border-radius: 6px;
            text-transform: uppercase;
            letter-spacing: 1px;
            user-select: none;
            -webkit-user-select: none;
            min-height: 40px;
            touch-action: manipulation;
            position: relative;
            overflow: hidden;
        }

        .send-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 215, 0, 0.3), transparent);
            transition: left 0.5s ease;
        }

        .send-btn:hover::before {
            left: 100%;
        }

        .send-btn:active {
            transform: scale(0.95);
        }

        .users-panel {
            display: flex;
            gap: 0.5rem;
            margin-top: 0.8rem;
            flex-wrap: wrap;
            justify-content: center;
        }

        .user-tag {
            padding: 0.3rem 0.6rem;
            background: linear-gradient(135deg, rgba(255, 0, 60, 0.15), rgba(0, 255, 65, 0.08));
            border: 1px solid rgba(255, 0, 60, 0.4);
            font-size: 0.65rem;
            color: var(--xmas-green);
            border-radius: 15px;
            position: relative;
            overflow: hidden;
        }

        .user-tag::after {
            content: '‚õÑ';
            position: absolute;
            right: -15px;
            top: 50%;
            transform: translateY(-50%);
            opacity: 0;
            transition: opacity 0.3s ease, right 0.3s ease;
        }

        .user-tag:hover::after {
            opacity: 0.7;
            right: 5px;
        }

        .hidden {
            display: none !important;
        }

        .danger-btn {
            background: linear-gradient(135deg, rgba(255, 0, 60, 0.12), rgba(255, 0, 60, 0.08));
            border-color: var(--error);
            color: var(--error);
        }

        .loading-terminal {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(13, 13, 13, 0.95), rgba(20, 10, 10, 0.9));
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            z-index: 10;
            border-radius: 8px;
        }

        .loading-content {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
            padding: 1rem;
        }

        .loading-text {
            color: var(--xmas-gold);
            font-size: 1.8rem;
            margin-bottom: 1rem;
            animation: welcomeGlow 3s ease-in-out infinite;
            font-weight: 800;
            letter-spacing: 2px;
            font-family: 'Rajdhani', sans-serif;
            text-align: center;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
        }

        @keyframes welcomeGlow {
            0%, 100% { 
                opacity: 1; 
                filter: hue-rotate(0deg);
                transform: translateY(0);
            }
            50% { 
                opacity: 0.8; 
                filter: hue-rotate(180deg);
                transform: translateY(-3px);
            }
        }

        .progress-bar {
            width: 250px;
            height: 2px;
            background: rgba(255, 0, 60, 0.2);
            border-radius: 2px;
            overflow: hidden;
            position: relative;
            margin-bottom: 1.5rem;
        }

        .progress-bar::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            width: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 215, 0, 0.6), transparent);
            animation: progressShine 2s linear infinite;
        }

        .progress {
            height: 100%;
            background: linear-gradient(90deg, var(--xmas-red), var(--xmas-gold), var(--xmas-green));
            width: 0%;
            animation: progressLoad 3.5s ease-in-out;
        }

        @keyframes progressLoad {
            0% { width: 0%; }
            100% { width: 100%; }
        }

        @keyframes progressShine {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        .xmas-tree-container {
            position: relative;
            width: 140px;
            height: 180px;
            margin-top: 0.5rem;
        }

        .xmas-tree {
            position: relative;
            width: 100%;
            height: 100%;
        }

        .tree-layer {
            position: absolute;
            width: 0;
            height: 0;
            border-left: 30px solid transparent;
            border-right: 30px solid transparent;
            border-bottom: 45px solid rgba(0, 255, 65, 0.3);
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            animation: treeGlow 4s ease-in-out infinite;
            z-index: 1;
        }

        .tree-layer:nth-child(2) {
            border-left-width: 45px;
            border-right-width: 45px;
            border-bottom-width: 60px;
            border-bottom-color: rgba(255, 215, 0, 0.4);
            bottom: 50px;
            animation-delay: 0.5s;
            z-index: 2;
        }

        .tree-layer:nth-child(3) {
            border-left-width: 60px;
            border-right-width: 60px;
            border-bottom-width: 75px;
            border-bottom-color: rgba(255, 0, 60, 0.5);
            bottom: 95px;
            animation-delay: 1s;
            z-index: 3;
        }

        @keyframes treeGlow {
            0%, 100% { 
                border-bottom-color: rgba(0, 255, 65, 0.3);
                filter: brightness(1) hue-rotate(0deg);
            }
            50% { 
                border-bottom-color: rgba(255, 215, 0, 0.5);
                filter: brightness(1.3) hue-rotate(120deg);
            }
        }

        .tree-trunk {
            position: absolute;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 16px;
            height: 25px;
            background: linear-gradient(to right, #8B4513, #A0522D);
            border-radius: 4px 4px 0 0;
            z-index: 0;
        }

        .digital-watermark {
            position: fixed;
            bottom: 10px;
            right: 10px;
            color: rgba(255, 0, 60, 0.08);
            font-size: 0.6rem;
            font-family: 'JetBrains Mono', monospace;
            pointer-events: none;
            z-index: 1000;
        }

        .destroy-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000000;
            z-index: 10000;
            pointer-events: none;
            opacity: 0;
        }

        .destroy-glitch {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                repeating-linear-gradient(0deg, 
                    rgba(255, 255, 255, 0.03) 0px, 
                    rgba(255, 255, 255, 0.03) 1px, 
                    transparent 1px, 
                    transparent 2px
                );
            z-index: 10001;
            pointer-events: none;
            opacity: 0;
        }

        .destroy-static {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 20% 50%, rgba(255, 255, 255, 0.1) 0%, transparent 20%),
                radial-gradient(circle at 80% 20%, rgba(255, 255, 255, 0.08) 0%, transparent 20%);
            z-index: 10002;
            pointer-events: none;
            opacity: 0;
        }

        .destroy-text {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: var(--error);
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.2rem;
            font-weight: 800;
            text-align: center;
            z-index: 10003;
            opacity: 0;
            text-shadow: 0 0 15px rgba(255, 0, 60, 0.7);
        }

        @keyframes destroyOverlay {
            0% { opacity: 0; }
            20% { opacity: 0.8; background: #1a1a1a; }
            40% { opacity: 0.9; background: #2a2a2a; }
            60% { opacity: 0.95; background: #1a1a1a; }
            80% { opacity: 0.8; background: #0a0a0a; }
            100% { opacity: 1; background: #000000; }
        }

        @keyframes destroyGlitch {
            0% { opacity: 0; transform: translateY(-5px); }
            25% { opacity: 0.8; transform: translateY(3px); filter: hue-rotate(90deg); }
            50% { opacity: 0.4; transform: translateY(-2px); filter: hue-rotate(180deg); }
            75% { opacity: 0.9; transform: translateY(1px); filter: hue-rotate(270deg); }
            100% { opacity: 0; transform: translateY(0); filter: hue-rotate(0deg); }
        }

        @keyframes destroyStatic {
            0% { opacity: 0; filter: blur(0px); }
            33% { opacity: 0.6; filter: blur(1px); }
            66% { opacity: 0.8; filter: blur(2px); }
            100% { opacity: 0; filter: blur(0px); }
        }

        @keyframes destroyText {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
            30% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
            60% { opacity: 0.9; transform: translate(-50%, -50%) scale(1); }
            90% { opacity: 0.8; transform: translate(-50%, -50%) scale(0.95); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
        }

        .top-garland {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 40px;
            z-index: 1000;
            pointer-events: none;
            overflow: hidden;
        }

        .garland-wire {
            position: absolute;
            top: 15px;
            left: 0;
            width: 100%;
            height: 2px;
            background: linear-gradient(90deg, 
                transparent 5%,
                rgba(255, 0, 60, 0.7) 10%,
                rgba(255, 215, 0, 0.7) 20%,
                rgba(0, 255, 65, 0.7) 30%,
                rgba(30, 144, 255, 0.7) 40%,
                rgba(189, 0, 255, 0.7) 50%,
                rgba(30, 144, 255, 0.7) 60%,
                rgba(0, 255, 65, 0.7) 70%,
                rgba(255, 215, 0, 0.7) 80%,
                rgba(255, 0, 60, 0.7) 90%,
                transparent 95%
            );
            animation: wireFlow 8s linear infinite;
        }

        @keyframes wireFlow {
            0% { filter: hue-rotate(0deg); }
            100% { filter: hue-rotate(360deg); }
        }

        .garland-light {
            position: absolute;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            z-index: 2;
            animation: lightPulse 2s infinite alternate;
            box-shadow: 
                0 0 10px currentColor,
                0 0 20px currentColor;
            top: 8px;
            transform: translateX(-50%);
            pointer-events: auto;
            cursor: pointer;
            transition: transform 0.2s ease;
        }

        .garland-light:hover {
            transform: translateX(-50%) scale(1.3);
            z-index: 1001;
        }

        @keyframes lightPulse {
            0% { 
                opacity: 0.7; 
                transform: translateX(-50%) scale(0.9);
                filter: brightness(0.9);
            }
            50% { 
                opacity: 1; 
                transform: translateX(-50%) scale(1.1);
                filter: brightness(1.3);
                box-shadow: 
                    0 0 15px currentColor,
                    0 0 30px currentColor;
            }
            100% { 
                opacity: 0.7; 
                transform: translateX(-50%) scale(0.9);
                filter: brightness(0.9);
            }
        }

        .snowflake {
            position: fixed;
            color: rgba(255, 255, 255, 0.9);
            font-size: 1rem;
            text-shadow: 0 0 5px rgba(0, 247, 255, 0.5);
            user-select: none;
            pointer-events: none;
            z-index: 1;
            animation: snowFall linear infinite;
        }

        @keyframes snowFall {
            to {
                transform: translateY(100vh) rotate(360deg);
            }
        }

        .confetti {
            position: fixed;
            width: 10px;
            height: 10px;
            opacity: 0.8;
            z-index: 1;
            pointer-events: none;
            animation: confettiFall linear forwards;
        }

        @keyframes confettiFall {
            to {
                transform: translateY(100vh) rotate(720deg);
                opacity: 0;
            }
        }

        .p2p-notification {
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.1), rgba(10, 0, 0, 0.9));
            border: 1px solid var(--p2p-color);
            color: var(--p2p-color);
            padding: 0.8rem;
            border-radius: 6px;
            font-size: 0.8rem;
            margin: 0.5rem 0;
            text-align: center;
            animation: glow 2s infinite alternate;
        }

        @keyframes glow {
            from { box-shadow: 0 0 5px var(--p2p-color); }
            to { box-shadow: 0 0 15px var(--p2p-color); }
        }

        @media (min-width: 768px) {
            .container { padding: 1.5rem; }
            .terminal { max-width: 700px; }
            .terminal-body { padding: 1.5rem; min-height: 380px; }
            .logo { font-size: 2.5rem; }
            .code-display { font-size: 2rem; letter-spacing: 8px; }
            .btn-group { grid-template-columns: 1fr 1fr; }
            .terminal-header { flex-direction: row; justify-content: space-between; align-items: center; }
            .chat-input-group { flex-direction: row; }
            .chat-info { flex-direction: row; justify-content: space-between; align-items: center; }
            .chat-container { height: 55vh; min-height: 400px; }
            .chat-messages { padding: 1.2rem; gap: 0.8rem; }
            .message { padding: 0.8rem; font-size: 0.85rem; }
            .loading-text { font-size: 2rem; }
            .progress-bar { width: 300px; }
            .xmas-tree-container { width: 150px; height: 190px; }
            .tree-layer { border-left-width: 35px; border-right-width: 35px; border-bottom-width: 50px; }
            .tree-layer:nth-child(2) { border-left-width: 50px; border-right-width: 50px; border-bottom-width: 65px; bottom: 55px; }
            .tree-layer:nth-child(3) { border-left-width: 65px; border-right-width: 65px; border-bottom-width: 80px; bottom: 100px; }
            .tree-trunk { width: 18px; height: 28px; }
            .top-garland { height: 45px; }
            .garland-light { width: 16px; height: 16px; top: 10px; }
            .garland-wire { top: 18px; }
            .mode-buttons { grid-template-columns: 1fr 1fr; }
        }

        @media (max-width: 480px) {
            .container { padding: 0.5rem; }
            .terminal-body { padding: 1rem; min-height: 350px; }
            .logo { font-size: 1.8rem; }
            .code-display { font-size: 1.5rem; letter-spacing: 4px; }
            .chat-container { height: calc(100vh - 140px); min-height: 380px; }
            .loading-text { font-size: 1.5rem; margin-bottom: 0.8rem; }
            .progress-bar { width: 200px; margin-bottom: 1rem; }
            .terminal-btn { padding: 0.8rem; font-size: 0.8rem; min-height: 42px; }
            .chat-input-group { gap: 0.6rem; }
            .send-btn { padding: 0.7rem; font-size: 0.7rem; min-height: 38px; }
            .chat-input { font-size: 16px; }
            .terminal-input { font-size: 16px; }
            .message { padding: 0.6rem; font-size: 0.75rem; }
            .users-panel { gap: 0.4rem; }
            .user-tag { padding: 0.2rem 0.5rem; font-size: 0.6rem; }
            .btn-group { gap: 0.6rem; }
            .xmas-tree-container { width: 120px; height: 160px; }
            .tree-layer { border-left-width: 25px; border-right-width: 25px; border-bottom-width: 40px; }
            .tree-layer:nth-child(2) { border-left-width: 40px; border-right-width: 40px; border-bottom-width: 55px; bottom: 45px; }
            .tree-layer:nth-child(3) { border-left-width: 55px; border-right-width: 55px; border-bottom-width: 70px; bottom: 85px; }
            .top-garland { height: 35px; }
            .garland-light { width: 12px; height: 12px; top: 7px; }
            .garland-wire { top: 13px; }
            .mode-buttons { grid-template-columns: 1fr; }
        }

        @media (max-width: 360px) {
            .logo { font-size: 1.6rem; }
            .terminal-title { font-size: 1.1rem; }
            .status-indicator { font-size: 0.7rem; padding: 0.3rem 0.6rem; }
            .chat-container { height: calc(100vh - 120px); min-height: 350px; }
            .terminal-btn { padding: 0.7rem; }
            .terminal-body { min-height: 320px; }
            .chat-input-container { padding: 0.8rem; }
            .xmas-tree-container { width: 100px; height: 140px; }
            .loading-text { font-size: 1.3rem; }
            .progress-bar { width: 180px; }
            .top-garland { height: 30px; }
            .garland-light { width: 10px; height: 10px; top: 5px; }
            .garland-wire { top: 10px; }
        }

        @media (max-height: 600px) {
            .chat-container { height: calc(100vh - 100px); min-height: 300px; }
            .terminal-body { padding: 1rem; min-height: 300px; }
            .chat-messages { padding: 0.8rem; gap: 0.6rem; }
            .message { padding: 0.6rem; font-size: 0.75rem; }
            .logo { font-size: 1.8rem; }
            .chat-input-container { padding: 0.8rem; }
            .loading-text { font-size: 1.5rem; margin-bottom: 0.8rem; }
            .xmas-tree-container { width: 100px; height: 140px; margin-top: 0.3rem; }
            .access-code { margin-bottom: 1rem; }
        }

        @media (max-height: 500px) {
            .terminal-body { min-height: 280px; }
            .chat-container { min-height: 280px; }
            .logo { font-size: 1.6rem; }
            .btn-group { margin-top: 0.8rem; gap: 0.6rem; }
            .terminal-btn { padding: 0.7rem; min-height: 40px; }
            .chat-input-container { padding: 0.7rem; }
            .chat-input-group { gap: 0.5rem; }
            .loading-text { font-size: 1.3rem; margin-bottom: 0.6rem; }
            .progress-bar { width: 180px; margin-bottom: 0.8rem; }
            .xmas-tree-container { display: none; }
            .access-code { margin-bottom: 0.8rem; padding: 1rem; }
        }

        @media (max-height: 400px) {
            .chat-container { height: calc(100vh - 80px); min-height: 250px; }
            .terminal-body { min-height: 250px; padding: 0.8rem; }
            .chat-messages { padding: 0.6rem; gap: 0.4rem; min-height: 150px; }
            .message { padding: 0.5rem; font-size: 0.7rem; }
            .chat-header { padding: 0.8rem; }
            .chat-input-container { padding: 0.6rem; }
            .send-btn { padding: 0.6rem; font-size: 0.7rem; min-height: 36px; }
            .chat-input { padding: 0.6rem; font-size: 0.8rem; min-height: 36px; }
            .loading-text { font-size: 1.2rem; margin-bottom: 0.5rem; }
            .progress-bar { width: 150px; margin-bottom: 0.6rem; }
            .xmas-tree-container { display: none; }
            .access-code { margin-bottom: 0.6rem; padding: 0.8rem; }
        }
    </style>
</head>
<body>
    <canvas id="xmasCanvas"></canvas>
    <div class="xmas-field"></div>
    <div class="holiday-grid"></div>
    
    <div class="top-garland" id="topGarland"></div>
    
    <div class="digital-watermark">SHADOW_NET_v5.0_P2P_ENC_256BIT</div>

    <div class="container">
        <div class="terminal">
            <div class="loading-terminal" id="loadingScreen">
                <div class="loading-content">
                    <div class="loading-text">WELCOME TO SHADOW NET</div>
                    <div class="progress-bar">
                        <div class="progress"></div>
                    </div>
                    <div class="xmas-tree-container">
                        <div class="xmas-tree">
                            <div class="tree-layer"></div>
                            <div class="tree-layer"></div>
                            <div class="tree-layer"></div>
                            <div class="tree-trunk"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="terminal-header">
                <div class="terminal-title">SHADOW NET</div>
                <div class="terminal-status">
                    <div class="status-indicator">
                        <div class="status-dot"></div>
                        <span>ENCRYPTION ACTIVE</span>
                    </div>
                    <div class="status-indicator">
                        <div class="status-dot" style="background: var(--neon-blue);"></div>
                        <span>NETWORK SYNC</span>
                    </div>
                </div>
            </div>

            <div class="terminal-body">
                <div id="modeScreen" class="access-screen">
                    <div class="logo">SHADOW NET</div>
                    <div class="tagline">QUANTUM SECURE COMMUNICATIONS</div>
                    
                    <div class="mode-selector">
                        <div class="mode-title">SELECT SECURITY MODE</div>
                        
                        <div class="mode-buttons">
                            <button class="mode-btn p2p" onclick="selectMode('p2p')">
                                <div class="mode-icon">üîí</div>
                                <div>P2P DIRECT CHAT</div>
                                <div class="mode-desc">
                                    Messages go directly between devices
                                    No servers involved ‚Ä¢ Max privacy
                                </div>
                            </button>
                            
                            <button class="mode-btn firebase" onclick="selectMode('firebase')">
                                <div class="mode-icon">üöÄ</div>
                                <div>FIREBASE CHAT</div>
                                <div class="mode-desc">
                                    Reliable connection ‚Ä¢ Message history
                                    Multiple participants ‚Ä¢ Server-based
                                </div>
                            </button>
                        </div>
                    </div>
                    
                    <div class="input-group">
                        <label class="input-label">DIGITAL IDENTITY (OPTIONAL)</label>
                        <input type="text" class="terminal-input" id="usernameInput" placeholder="anonymous">
                    </div>

                    <div class="btn-group">
                        <button class="terminal-btn primary" id="createRoomBtn">CREATE SESSION</button>
                        <button class="terminal-btn" id="showJoinFormBtn">JOIN SESSION</button>
                        <button class="terminal-btn danger" id="deleteDecoyRoomsBtn">DELETE DECOY ROOMS</button>
                        <button class="terminal-btn" id="createFakeRoomsBtn">CREATE DECOY ROOMS</button>
                        <button class="terminal-btn danger btn-group-full-width" id="deleteEmptyRoomsBtn">DELETE EMPTY ROOMS</button>
                    </div>

                    <div id="joinForm" class="hidden">
                        <div class="input-group">
                            <label class="input-label">ACCESS CODE</label>
                            <input type="text" class="terminal-input" id="roomCodeInput" placeholder="ENTER 6-DIGIT CRYPTO-CODE">
                        </div>
                        <button class="terminal-btn primary" id="joinRoomBtn">ESTABLISH CONNECTION</button>
                    </div>

                    <div id="sessionCreated" class="hidden">
                        <div class="access-code">
                            <div class="input-label">SESSION ACCESS CODE</div>
                            <div class="code-display" id="roomCodeDisplay"></div>
                            <button class="terminal-btn" id="copyRoomCodeBtn">COPY CRYPTO-CODE</button>
                        </div>
                        <div id="p2pNotification" class="hidden p2p-notification">
                            ‚ö° P2P MODE: Share this code with ONE person
                            Messages will go directly between devices
                        </div>
                        <button class="terminal-btn primary" style="margin-top: 0.5rem;" id="enterChatBtn">ENTER SECURE CHAT</button>
                    </div>
                </div>

                <div class="chat-container" id="chatScreen">
                    <div class="chat-header">
                        <div class="chat-info">
                            <div>
                                <div style="font-size: 0.8rem; color: var(--text-secondary);">ACTIVE SESSION</div>
                                <div class="room-code" id="currentRoomCode"></div>
                            </div>
                            <div class="status-indicator">
                                <div class="status-dot"></div>
                                <span id="connectionStatus">CONNECTION SECURE</span>
                            </div>
                        </div>
                        <div class="users-panel" id="usersList"></div>
                    </div>

                    <div class="chat-messages" id="chatMessages"></div>

                    <div class="chat-input-container">
                        <div class="chat-input-group">
                            <input type="text" class="chat-input" id="messageInput" placeholder="TRANSMIT ENCRYPTED MESSAGE...">
                            <button class="send-btn" id="sendMessageBtn">SEND</button>
                            <button class="send-btn danger-btn" id="destroyChatBtn">DESTROY CHAT</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const firebaseConfig = {
            apiKey: "AIzaSyDrY5azkfFacBNQ36ok8O7eMKQGPTH9Xs4",
            authDomain: "shadow-net-chat.firebaseapp.com",
            databaseURL: "https://shadow-net-chat-default-rtdb.firebaseio.com",
            projectId: "shadow-net-chat",
            storageBucket: "shadow-net-chat.firebasestorage.app",
            messagingSenderId: "477144065218",
            appId: "1:477144065218:web:a27ed2f1f92727f8e7475b"
        };

        try {
            if (!firebase.apps.length) {
                firebase.initializeApp(firebaseConfig);
            }
        } catch (error) {}

        let currentMode = null;
        let currentRoom = null;
        let currentUser = null;
        let roomRef = null;
        let usersRef = null;
        let messagesRef = null;
        let myUsername = 'anonymous';
        let disconnectAnimationShown = false;
        let userUID = null;
        let roomKey = null;
        let xmasAnimationId = null;
        let isAuthenticated = false;
        let roomCheckInterval = null;
        let messageListener = null;
        let usersListener = null;
        let heartbeatInterval = null;
        let syncInterval = null;
        let usersUpdateTimeout = null;
        let destroyListener = null;
        let isDestroyAnimationActive = false;
        let decoyRoomManager = {
            targetCount: 0,
            activeRooms: new Set(),
            nodeIntervals: new Map(),
            maintenanceInterval: null,
            isActive: false
        };

        let p2pConnection = null;
        let p2pDataChannel = null;
        let p2pSignalingRef = null;
        let p2pIceCandidatesRef = null;
        let p2pOfferRef = null;
        let p2pAnswerRef = null;
        let p2pDestroyRef = null;
        let p2pConnected = false;
        let remoteUsername = 'anonymous';
        let isP2PInitiator = false;

        const xmasChars = "‚ùÑ‚ùÖ‚ùÜ";
        const xmasCanvas = document.getElementById('xmasCanvas');
        const ctx = xmasCanvas.getContext('2d');
        let xmasParticles = [];
        let activeConfetti = [];
        let lastConfettiTime = 0;
        let lastAutoConfettiTime = 0;
        const maxConfetti = 25;
        const maxSnowflakes = 30;
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

        const nodeMessages = [
            "Traffic intercepted from segment 7B",
            "AES-256 encryption active",
            "Channel secure for transmission",
            "Port scanning detected",
            "Ghost protocol activated",
            "Node synchronization complete",
            "Traffic masked successfully",
            "Suspicious packets detected",
            "Quantum protocol active",
            "Routing through shadow core",
            "DDoS protection active",
            "End-to-end encryption established",
            "Channel ready for data transfer",
            "Network monitoring active",
            "All systems operational"
        ];

        const userNames = [
            "ghost", "phantom", "shadow", "raven", "wolf", "viper", "hawk", "falcon",
            "specter", "wraith", "hunter", "ranger", "sentinel", "guardian", "watcher",
            "strider", "nomad", "voyager", "pioneer", "explorer", "operative", "agent",
            "cypher", "nexus", "vector", "quantum", "neural", "digital", "crypto",
            "stealth", "silent", "covert", "hidden", "unknown", "mystery", "enigma"
        ];

        let activeSnowflakes = [];
        let isPageVisible = true;

        document.addEventListener('visibilitychange', () => {
            isPageVisible = !document.hidden;
            if (isPageVisible) {
                resumeAnimations();
            } else {
                pauseAnimations();
            }
        });

        function pauseAnimations() {
            if (xmasAnimationId) {
                cancelAnimationFrame(xmasAnimationId);
                xmasAnimationId = null;
            }
        }

        function resumeAnimations() {
            if (!xmasAnimationId && isPageVisible) {
                animateXmasCanvas();
            }
        }

        function showP2PConnecting() {
            const overlay = document.createElement('div');
            overlay.id = 'p2pConnectingOverlay';
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.9);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10000;
                color: var(--p2p-color);
                font-family: 'JetBrains Mono', monospace;
                flex-direction: column;
                gap: 20px;
            `;
            
            overlay.innerHTML = `
                <div style="font-size: 1.5rem; text-align: center;">
                    üîó ESTABLISHING P2P CONNECTION...
                </div>
                <div style="font-size: 0.9rem; opacity: 0.7;">
                    This may take a few seconds
                </div>
                <div class="progress-bar" style="width: 200px; margin-top: 20px;">
                    <div class="progress" style="animation: progressLoad 15s ease-in-out;"></div>
                </div>
            `;
            
            document.body.appendChild(overlay);
        }

        function hideP2PConnecting() {
            const overlay = document.getElementById('p2pConnectingOverlay');
            if (overlay) overlay.remove();
        }

        function createTopGarland() {
            const garlandContainer = document.getElementById('topGarland');
            garlandContainer.innerHTML = '';
            
            const wire = document.createElement('div');
            wire.className = 'garland-wire';
            garlandContainer.appendChild(wire);
            
            const colors = [
                '#ff003c', '#ff4500', '#ffd700', '#00ff41', '#1e90ff', 
                '#9370db', '#ff1493', '#00ffff', '#ff69b4', '#7cfc00'
            ];
            
            const lightCount = Math.floor(window.innerWidth / (isMobile ? 50 : 35));
            
            for (let i = 0; i < lightCount; i++) {
                const light = document.createElement('div');
                light.className = 'garland-light';
                
                const position = (i / (lightCount - 1)) * 100;
                const color = colors[Math.floor(Math.random() * colors.length)];
                
                light.style.left = `${position}%`;
                light.style.backgroundColor = color;
                light.style.animationDelay = `${(i % 10) * 0.2}s`;
                light.style.filter = `hue-rotate(${i * 15}deg)`;
                
                light.addEventListener('click', () => {
                    const newColor = colors[Math.floor(Math.random() * colors.length)];
                    light.style.backgroundColor = newColor;
                    light.style.animation = 'none';
                    setTimeout(() => {
                        light.style.animation = 'lightPulse 2s infinite alternate';
                    }, 50);
                    
                    createConfetti();
                });
                
                light.addEventListener('mouseenter', () => {
                    if (!light.clicked) {
                        light.style.transform = 'translateX(-50%) scale(1.4)';
                    }
                });
                
                light.addEventListener('mouseleave', () => {
                    if (!light.clicked) {
                        light.style.transform = 'translateX(-50%) scale(1)';
                    }
                });
                
                garlandContainer.appendChild(light);
            }
        }

        function getRandomXmasColor() {
            const colors = [
                '#ff003c', '#ff4500', '#ffd700', '#00ff41', '#1e90ff',
                '#ff1493', '#00ffff', '#ff69b4', '#7cfc00', '#9370db'
            ];
            return colors[Math.floor(Math.random() * colors.length)];
        }

        function initXmasCanvas() {
            if (xmasAnimationId) {
                cancelAnimationFrame(xmasAnimationId);
            }
            
            xmasCanvas.width = window.innerWidth;
            xmasCanvas.height = window.innerHeight;
            
            const particleCount = isMobile ? 25 : 40;
            
            xmasParticles = [];
            for (let i = 0; i < particleCount; i++) {
                xmasParticles.push({
                    x: Math.random() * xmasCanvas.width,
                    y: Math.random() * -xmasCanvas.height,
                    speed: Math.random() * 0.3 + 0.15,
                    char: xmasChars.charAt(Math.floor(Math.random() * xmasChars.length)),
                    size: Math.random() * 6 + 14,
                    opacity: Math.random() * 0.5 + 0.3,
                    sway: Math.random() * 2 - 1,
                    rotation: Math.random() * 360,
                    color: getRandomXmasColor()
                });
            }
            
            if (isPageVisible) {
                animateXmasCanvas();
            }
        }

        function animateXmasCanvas() {
            if (!isPageVisible) return;
            
            ctx.clearRect(0, 0, xmasCanvas.width, xmasCanvas.height);
            
            xmasParticles.forEach((particle, i) => {
                ctx.save();
                ctx.translate(particle.x + particle.sway * Math.sin(Date.now() / 1000 + i), particle.y);
                ctx.rotate(particle.rotation * Math.PI / 180);
                
                ctx.font = `bold ${particle.size}px Arial, sans-serif`;
                ctx.fillStyle = particle.color;
                ctx.globalAlpha = particle.opacity;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(particle.char, 0, 0);
                
                ctx.restore();
                
                particle.y += particle.speed;
                particle.rotation += 0.2;
                particle.sway = Math.sin(Date.now() / 2000 + i) * 0.8;
                
                if (particle.y > xmasCanvas.height) {
                    particle.y = Math.random() * -100;
                    particle.x = Math.random() * xmasCanvas.width;
                    particle.char = xmasChars.charAt(Math.floor(Math.random() * xmasChars.length));
                    particle.speed = Math.random() * 0.3 + 0.15;
                    particle.opacity = Math.random() * 0.5 + 0.3;
                    particle.color = getRandomXmasColor();
                }
            });
            
            xmasAnimationId = requestAnimationFrame(animateXmasCanvas);
        }

        function createSnowflakes() {
            const snowflakeCount = Math.min(isMobile ? 15 : 25, maxSnowflakes);
            
            for (let i = 0; i < snowflakeCount; i++) {
                setTimeout(() => {
                    if (activeSnowflakes.length >= maxSnowflakes) {
                        const oldestSnowflake = activeSnowflakes.shift();
                        if (oldestSnowflake && oldestSnowflake.parentNode) {
                            oldestSnowflake.remove();
                        }
                    }
                    
                    const snowflake = document.createElement('div');
                    snowflake.className = 'snowflake';
                    snowflake.innerHTML = '‚ùÑ';
                    snowflake.style.left = `${Math.random() * 100}%`;
                    snowflake.style.fontSize = `${Math.random() * 10 + 6}px`;
                    snowflake.style.opacity = Math.random() * 0.6 + 0.2;
                    snowflake.style.animationDuration = `${Math.random() * 8 + 6}s`;
                    snowflake.style.animationDelay = `${Math.random() * 2}s`;
                    
                    document.body.appendChild(snowflake);
                    activeSnowflakes.push(snowflake);
                    
                    snowflake.addEventListener('animationend', () => {
                        const index = activeSnowflakes.indexOf(snowflake);
                        if (index > -1) {
                            activeSnowflakes.splice(index, 1);
                        }
                        snowflake.remove();
                        createSingleSnowflake();
                    });
                }, i * 150);
            }
        }

        function createSingleSnowflake() {
            const now = Date.now();
            if (now - lastConfettiTime < 150) return;
            
            if (activeSnowflakes.length >= maxSnowflakes) {
                const oldestSnowflake = activeSnowflakes.shift();
                if (oldestSnowflake && oldestSnowflake.parentNode) {
                    oldestSnowflake.remove();
                }
            }
            
            const snowflake = document.createElement('div');
            snowflake.className = 'snowflake';
            snowflake.innerHTML = '‚ùÑ';
            snowflake.style.left = `${Math.random() * 100}%`;
            snowflake.style.fontSize = `${Math.random() * 10 + 6}px`;
            snowflake.style.opacity = Math.random() * 0.6 + 0.2;
            snowflake.style.animationDuration = `${Math.random() * 8 + 6}s`;
            
            document.body.appendChild(snowflake);
            activeSnowflakes.push(snowflake);
            
            snowflake.addEventListener('animationend', () => {
                const index = activeSnowflakes.indexOf(snowflake);
                if (index > -1) {
                    activeSnowflakes.splice(index, 1);
                }
                snowflake.remove();
            });
            
            lastConfettiTime = now;
        }

        function createAutoConfetti() {
            const now = Date.now();
            if (now - lastAutoConfettiTime < 7000) return;
            
            const confettiCount = isMobile ? 6 : 12;
            const colors = ['#ff003c', '#00ff41', '#ffd700', '#1e90ff', '#ffffff'];
            const shapes = ['‚ùÑ', '‚ú®', '‚óè', '‚óÜ', '‚òÖ'];
            
            if (activeConfetti.length > maxConfetti) {
                const toRemove = activeConfetti.length - maxConfetti;
                for (let i = 0; i < toRemove; i++) {
                    const confetti = activeConfetti[i];
                    if (confetti && confetti.parentNode) {
                        confetti.remove();
                    }
                }
                activeConfetti = activeConfetti.slice(toRemove);
            }
            
            for (let i = 0; i < confettiCount; i++) {
                const confetti = document.createElement('div');
                confetti.className = 'confetti';
                confetti.innerHTML = shapes[Math.floor(Math.random() * shapes.length)];
                confetti.style.left = `${Math.random() * 100}%`;
                confetti.style.top = '-20px';
                confetti.style.color = colors[Math.floor(Math.random() * colors.length)];
                confetti.style.fontSize = `${Math.random() * 8 + 10}px`;
                confetti.style.animationDuration = `${Math.random() * 1.5 + 1}s`;
                confetti.style.animationDelay = `${Math.random() * 0.2}s`;
                
                document.body.appendChild(confetti);
                activeConfetti.push(confetti);
                
                confetti.addEventListener('animationend', () => {
                    const index = activeConfetti.indexOf(confetti);
                    if (index > -1) {
                        activeConfetti.splice(index, 1);
                    }
                    confetti.remove();
                });
            }
            
            lastAutoConfettiTime = now;
        }

        function createConfetti() {
            const now = Date.now();
            if (now - lastConfettiTime < 250) return;
            
            const confettiCount = isMobile ? 8 : 15;
            const colors = ['#ff003c', '#00ff41', '#ffd700', '#1e90ff', '#ffffff'];
            const shapes = ['‚ùÑ', '‚ú®', '‚óè', '‚óÜ', '‚òÖ'];
            
            if (activeConfetti.length > maxConfetti) {
                const toRemove = activeConfetti.length - maxConfetti;
                for (let i = 0; i < toRemove; i++) {
                    const confetti = activeConfetti[i];
                    if (confetti && confetti.parentNode) {
                        confetti.remove();
                    }
                }
                activeConfetti = activeConfetti.slice(toRemove);
            }
            
            for (let i = 0; i < confettiCount; i++) {
                const confetti = document.createElement('div');
                confetti.className = 'confetti';
                confetti.innerHTML = shapes[Math.floor(Math.random() * shapes.length)];
                confetti.style.left = `${Math.random() * 100}%`;
                confetti.style.top = '-20px';
                confetti.style.color = colors[Math.floor(Math.random() * colors.length)];
                confetti.style.fontSize = `${Math.random() * 8 + 10}px`;
                confetti.style.animationDuration = `${Math.random() * 1.5 + 1}s`;
                confetti.style.animationDelay = `${Math.random() * 0.2}s`;
                
                document.body.appendChild(confetti);
                activeConfetti.push(confetti);
                
                confetti.addEventListener('animationend', () => {
                    const index = activeConfetti.indexOf(confetti);
                    if (index > -1) {
                        activeConfetti.splice(index, 1);
                    }
                    confetti.remove();
                });
            }
            
            lastConfettiTime = now;
        }

        function cleanUpOldConfetti() {
            activeConfetti = activeConfetti.filter(confetti => {
                if (!confetti || !confetti.parentNode) return false;
                const style = window.getComputedStyle(confetti);
                const opacity = parseFloat(style.opacity);
                return opacity > 0.1;
            });
            
            activeSnowflakes = activeSnowflakes.filter(snowflake => {
                if (!snowflake || !snowflake.parentNode) return false;
                const style = window.getComputedStyle(snowflake);
                const opacity = parseFloat(style.opacity);
                return opacity > 0.1;
            });
        }

        function generateRandomChars(length) {
            if (length <= 0) return '';
            
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*';
            const charsLength = chars.length;
            let result = '';
            
            for (let i = 0; i < length; i++) {
                result += chars.charAt(Math.floor(Math.random() * charsLength));
            }
            return result;
        }

        function addMessageWithDecryptAnimation(content, username, isMe, timestamp) {
            const messagesContainer = document.getElementById('chatMessages');
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${isMe ? 'outgoing' : 'incoming'}`;
            
            const messageId = 'msg-' + timestamp + '-' + Math.random().toString(36).substr(2, 9);
            
            messageDiv.innerHTML = `
                <div class="message-header">
                    <span class="message-sender">${username}</span>
                </div>
                <div class="message-content">
                    <span class="decrypting-text" id="${messageId}">${generateRandomChars(content.length)}</span>
                </div>
            `;
            
            messagesContainer.appendChild(messageDiv);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
            
            const decryptElement = document.getElementById(messageId);
            startDecryptAnimation(decryptElement, content);
        }

        function startDecryptAnimation(element, targetText) {
            const totalLength = targetText.length;
            let currentIndex = 0;
            let lastTime = 0;
            let animationFrameId = null;
            
            const charsCache = {};
            const getRandomChars = (length) => {
                if (!charsCache[length]) {
                    charsCache[length] = generateRandomChars(length);
                }
                return charsCache[length];
            };
            
            const isElementVisible = () => {
                const rect = element.getBoundingClientRect();
                const messagesContainer = document.getElementById('chatMessages');
                const containerRect = messagesContainer.getBoundingClientRect();
                
                return rect.top >= containerRect.top && 
                       rect.bottom <= containerRect.bottom;
            };
            
            const decryptFrame = (timestamp) => {
                if (!lastTime) lastTime = timestamp;
                const deltaTime = timestamp - lastTime;
                
                if (currentIndex >= totalLength) {
                    element.innerHTML = targetText;
                    cancelAnimationFrame(animationFrameId);
                    return;
                }
                
                const visible = isElementVisible();
                const baseSpeed = visible ? 20 : 40;
                const charsPerFrame = Math.max(1, Math.floor(totalLength / 80) + 1);
                
                if (deltaTime > baseSpeed) {
                    const charsToProcess = Math.min(charsPerFrame, totalLength - currentIndex);
                    currentIndex += charsToProcess;
                    
                    const currentText = targetText.substring(0, currentIndex);
                    const remainingLength = totalLength - currentIndex;
                    const randomChars = getRandomChars(remainingLength);
                    
                    element.innerHTML = currentText + `<span class="decrypting-char">${randomChars}</span>`;
                    lastTime = timestamp;
                }
                
                animationFrameId = requestAnimationFrame(decryptFrame);
            };
            
            animationFrameId = requestAnimationFrame(decryptFrame);
            
            element.dataset.animationId = animationFrameId;
        }

        function generateRandomUserID() {
            const timestamp = Date.now().toString(36);
            const randomPart = Math.random().toString(36).substr(2, 12);
            return timestamp + '_' + randomPart;
        }

        function selectMode(mode) {
            currentMode = mode;
            document.getElementById('modeScreen').classList.remove('hidden');
            updateModeIndicator();
        }

        function updateModeIndicator() {
            const statusElement = document.getElementById('connectionStatus');
            if (currentMode === 'p2p') {
                statusElement.textContent = 'P2P DIRECT CONNECTION';
                statusElement.style.color = 'var(--p2p-color)';
            } else {
                statusElement.textContent = 'FIREBASE CONNECTION';
                statusElement.style.color = 'var(--firebase-color)';
            }
        }

        async function ensureAuthentication() {
            if (isAuthenticated && currentUser) return true;
            
            try {
                const currentAuth = firebase.auth().currentUser;
                if (currentAuth) {
                    currentUser = currentAuth;
                    isAuthenticated = true;
                    return true;
                }
                
                const userCredential = await firebase.auth().signInAnonymously();
                currentUser = userCredential.user;
                isAuthenticated = true;
                return true;
                
            } catch (error) {
                if (currentMode === 'p2p') {
                    return false;
                }
                
                alert('Network authentication failed. Check console.');
                return false;
            }
        }

        async function getRoomStats() {
            try {
                const database = firebase.database();
                const roomsRef = database.ref('rooms');
                const snapshot = await roomsRef.once('value');
                const rooms = snapshot.val() || {};
                
                const totalRooms = Object.keys(rooms).length;
                let decoyRooms = 0;
                
                for (const roomId in rooms) {
                    if (rooms[roomId] && rooms[roomId].s_arch === true) {
                        decoyRooms++;
                    }
                }
                
                return { totalRooms, decoyRooms };
            } catch (error) {
                return { totalRooms: 0, decoyRooms: 0 };
            }
        }

        async function deleteEmptyRooms() {
            try {
                if (!await ensureAuthentication()) return;
                
                const database = firebase.database();
                const roomsRef = database.ref('rooms');
                const snapshot = await roomsRef.once('value');
                const rooms = snapshot.val() || {};
                
                let emptyRooms = [];
                let deletePromises = [];
                
                for (const roomId in rooms) {
                    const room = rooms[roomId];
                    if (room && room.users) {
                        const users = room.users;
                        if (Object.keys(users).length === 0) {
                            emptyRooms.push(roomId);
                            deletePromises.push(roomsRef.child(roomId).remove());
                        }
                    } else if (room && !room.s_arch) {
                        emptyRooms.push(roomId);
                        deletePromises.push(roomsRef.child(roomId).remove());
                    }
                }
                
                if (emptyRooms.length === 0) {
                    alert('No empty rooms found');
                    return;
                }
                
                await Promise.all(deletePromises);
                
                alert(`Deleted ${emptyRooms.length} empty rooms`);
                
            } catch (error) {
            }
        }

        function stopAllDecoyProcesses() {
            decoyRoomManager.isActive = false;
            decoyRoomManager.targetCount = 0;
            
            if (decoyRoomManager.maintenanceInterval) {
                clearInterval(decoyRoomManager.maintenanceInterval);
                decoyRoomManager.maintenanceInterval = null;
            }
            
            stopAllNodes();
        }

        async function stopAllNodes() {
            for (const [roomId, interval] of decoyRoomManager.nodeIntervals) {
                clearInterval(interval);
            }
            decoyRoomManager.nodeIntervals.clear();
        }

        async function deleteDecoyRooms() {
            try {
                if (!await ensureAuthentication()) return;
                
                const stats = await getRoomStats();
                
                if (stats.decoyRooms === 0) {
                    alert('No decoy rooms found');
                    return;
                }
                
                if (!confirm(`WARNING: This will delete ${stats.decoyRooms} decoy rooms.\nContinue?`)) {
                    return;
                }
                
                stopAllDecoyProcesses();
                
                const database = firebase.database();
                const roomsRef = database.ref('rooms');
                const snapshot = await roomsRef.once('value');
                const rooms = snapshot.val() || {};
                
                let deleteCount = 0;
                const decoyRooms = [];
                
                for (const roomId in rooms) {
                    const room = rooms[roomId];
                    if (room && room.s_arch === true) {
                        decoyRooms.push(roomId);
                    }
                }
                
                for (let i = 0; i < decoyRooms.length; i++) {
                    const roomId = decoyRooms[i];
                    setTimeout(async () => {
                        try {
                            await roomsRef.child(roomId).remove();
                            decoyRoomManager.activeRooms.delete(roomId);
                            deleteCount++;
                            
                            if (deleteCount === decoyRooms.length) {
                                alert(`Deleted ${deleteCount} decoy rooms`);
                            }
                        } catch (error) {
                        }
                    }, Math.random() * 3000 + 1000);
                }
                
            } catch (error) {
            }
        }

        async function createFakeRooms() {
            try {
                if (!await ensureAuthentication()) return;
                
                const roomCount = Math.floor(Math.random() * 21) + 10;
                
                if (!confirm(`Create ${roomCount} decoy rooms?`)) {
                    return;
                }
                
                decoyRoomManager.targetCount = roomCount;
                decoyRoomManager.isActive = true;
                
                await createDecoyRoomsWithDelay(roomCount);
                
                startDecoyRoomMaintenance();
                
            } catch (error) {
            }
        }

        async function createDecoyRoomsWithDelay(totalCount) {
            if (!decoyRoomManager.isActive) return;
            
            const database = firebase.database();
            const roomsRef = database.ref('rooms');
            
            let createdCount = 0;
            
            const createRoomWithDelay = async (index) => {
                if (index >= totalCount || !decoyRoomManager.isActive) return;
                
                const delay = Math.random() * 1200 + 300;
                
                setTimeout(async () => {
                    try {
                        const roomId = generateRoomId();
                        const roomKey = await generateRoomKey();
                        if (!roomKey) return;
                        
                        const exportedKey = await exportKey(roomKey);
                        
                        await roomsRef.child(roomId).set({
                            roomKey: exportedKey,
                            createdAt: Date.now(),
                            s_arch: true
                        });
                        
                        decoyRoomManager.activeRooms.add(roomId);
                        await addUsersToRoom(roomId, roomKey);
                        createdCount++;
                        
                        createRoomWithDelay(index + 1);
                        
                    } catch (error) {
                        createRoomWithDelay(index + 1);
                    }
                }, delay);
            };
            
            createRoomWithDelay(0);
        }

        async function addUsersToRoom(roomId, roomKey) {
            if (!decoyRoomManager.isActive) return;
            
            const userCount = Math.floor(Math.random() * 5) + 1;
            const database = firebase.database();
            const roomRef = database.ref('rooms/' + roomId);
            
            for (let i = 0; i < userCount; i++) {
                const userId = generateRandomUserID();
                const randomUsername = userNames[Math.floor(Math.random() * userNames.length)] + '_' + (Math.floor(Math.random() * 99) + 1);
                const encryptedUsername = await encryptMessageWithKey(randomUsername, roomKey);
                
                if (encryptedUsername) {
                    await roomRef.child('users').child(userId).set({
                        encryptedUsername: encryptedUsername,
                        lastSeen: Date.now(),
                        node: true
                    });
                }
            }
            
            const nodeInterval = setInterval(async () => {
                if (!decoyRoomManager.isActive) {
                    clearInterval(nodeInterval);
                    return;
                }
                
                const roomCheck = await roomRef.once('value');
                if (!roomCheck.exists()) {
                    clearInterval(nodeInterval);
                    decoyRoomManager.nodeIntervals.delete(roomId);
                    return;
                }
                
                if (Math.random() > 0.3) {
                    const message = nodeMessages[Math.floor(Math.random() * nodeMessages.length)];
                    const encryptedContent = await encryptMessageWithKey(message, roomKey);
                    const randomUsername = userNames[Math.floor(Math.random() * userNames.length)] + '_' + (Math.floor(Math.random() * 99) + 1);
                    const encryptedUsername = await encryptMessageWithKey(randomUsername, roomKey);
                    
                    if (encryptedContent && encryptedUsername) {
                        await roomRef.child('messages').push({
                            encryptedContent: encryptedContent,
                            encryptedUsername: encryptedUsername,
                            userId: generateRandomUserID(),
                            timestamp: Date.now(),
                            node: true
                        });
                    }
                }
            }, Math.random() * 20000 + 10000);
            
            decoyRoomManager.nodeIntervals.set(roomId, nodeInterval);
        }

        function startDecoyRoomMaintenance() {
            if (decoyRoomManager.maintenanceInterval) {
                clearInterval(decoyRoomManager.maintenanceInterval);
            }
            
            decoyRoomManager.maintenanceInterval = setInterval(async () => {
                if (!decoyRoomManager.isActive) return;
                
                const currentStats = await getRoomStats();
                const currentDecoyCount = currentStats.decoyRooms;
                
                if (currentDecoyCount < decoyRoomManager.targetCount) {
                    const needed = decoyRoomManager.targetCount - currentDecoyCount;
                    await createAdditionalDecoyRooms(needed);
                } else if (currentDecoyCount > decoyRoomManager.targetCount) {
                    const excess = currentDecoyCount - decoyRoomManager.targetCount;
                    await removeExcessDecoyRooms(excess);
                }
                
                await randomlyRefreshRooms();
                
            }, 30000);
        }

        async function createAdditionalDecoyRooms(count) {
            if (count <= 0 || !decoyRoomManager.isActive) return;
            
            const database = firebase.database();
            const roomsRef = database.ref('rooms');
            
            for (let i = 0; i < count; i++) {
                try {
                    const roomId = generateRoomId();
                    if (decoyRoomManager.activeRooms.has(roomId)) continue;
                    
                    const roomKey = await generateRoomKey();
                    if (!roomKey) continue;
                    
                    const exportedKey = await exportKey(roomKey);
                    
                    await roomsRef.child(roomId).set({
                        roomKey: exportedKey,
                        createdAt: Date.now(),
                        s_arch: true
                    });
                    
                    decoyRoomManager.activeRooms.add(roomId);
                    await addUsersToRoom(roomId, roomKey);
                    
                } catch (error) {
                }
            }
        }

        async function removeExcessDecoyRooms(count) {
            if (count <= 0 || !decoyRoomManager.isActive) return;
            
            const database = firebase.database();
            const roomsRef = database.ref('rooms');
            const snapshot = await roomsRef.once('value');
            const rooms = snapshot.val() || {};
            
            let removed = 0;
            const roomIds = Object.keys(rooms);
            
            for (const roomId of roomIds) {
                if (removed >= count) break;
                
                const room = rooms[roomId];
                if (room && room.s_arch === true && decoyRoomManager.activeRooms.has(roomId)) {
                    if (decoyRoomManager.nodeIntervals.has(roomId)) {
                        clearInterval(decoyRoomManager.nodeIntervals.get(roomId));
                        decoyRoomManager.nodeIntervals.delete(roomId);
                    }
                    
                    await roomsRef.child(roomId).remove();
                    decoyRoomManager.activeRooms.delete(roomId);
                    removed++;
                }
            }
        }

        async function randomlyRefreshRooms() {
            if (decoyRoomManager.activeRooms.size === 0 || !decoyRoomManager.isActive) return;
            
            const refreshChance = 0.5;
            if (Math.random() > refreshChance) return;
            
            const roomsToRefresh = Math.floor(Math.random() * 5) + 2;
            const roomArray = Array.from(decoyRoomManager.activeRooms);
            
            for (let i = 0; i < roomsToRefresh && i < roomArray.length; i++) {
                const roomId = roomArray[Math.floor(Math.random() * roomArray.length)];
                await refreshDecoyRoom(roomId);
            }
        }

        async function refreshDecoyRoom(roomId) {
            if (!decoyRoomManager.isActive) return;
            
            const database = firebase.database();
            const roomRef = database.ref('rooms/' + roomId);
            
            if (decoyRoomManager.nodeIntervals.has(roomId)) {
                clearInterval(decoyRoomManager.nodeIntervals.get(roomId));
                decoyRoomManager.nodeIntervals.delete(roomId);
            }
            
            await roomRef.remove();
            decoyRoomManager.activeRooms.delete(roomId);
            
            setTimeout(async () => {
                if (!decoyRoomManager.isActive) return;
                
                const newRoomId = generateRoomId();
                const roomKey = await generateRoomKey();
                if (!roomKey) return;
                
                const exportedKey = await exportKey(roomKey);
                
                await database.ref('rooms').child(newRoomId).set({
                    roomKey: exportedKey,
                    createdAt: Date.now(),
                    s_arch: true
                });
                
                decoyRoomManager.activeRooms.add(newRoomId);
                await addUsersToRoom(newRoomId, roomKey);
                
            }, Math.random() * 15000);
        }

        async function encryptMessageWithKey(message, key) {
            try {
                const encoder = new TextEncoder();
                const encoded = encoder.encode(message);
                
                const iv = crypto.getRandomValues(new Uint8Array(12));
                
                const encrypted = await crypto.subtle.encrypt(
                    { name: "AES-GCM", iv: iv },
                    key,
                    encoded
                );

                const combined = new Uint8Array(iv.length + encrypted.byteLength);
                combined.set(iv, 0);
                combined.set(new Uint8Array(encrypted), iv.length);

                return btoa(String.fromCharCode(...combined));
            } catch (error) {
                return null;
            }
        }

        async function generateRoomKey() {
            try {
                const key = await crypto.subtle.generateKey(
                    { name: "AES-GCM", length: 256 },
                    true,
                    ["encrypt", "decrypt"]
                );
                return key;
            } catch (error) {
                return null;
            }
        }

        async function exportKey(key) {
            try {
                const exported = await crypto.subtle.exportKey("jwk", key);
                return exported;
            } catch (error) {
                return null;
            }
        }

        async function importKey(jwk) {
            try {
                return await crypto.subtle.importKey(
                    "jwk",
                    jwk,
                    { name: "AES-GCM", length: 256 },
                    true,
                    ["encrypt", "decrypt"]
                );
            } catch (error) {
                return null;
            }
        }

        async function encryptMessage(message) {
            try {
                if (!roomKey) return null;

                const encoder = new TextEncoder();
                const encoded = encoder.encode(message);
                
                const iv = crypto.getRandomValues(new Uint8Array(12));
                
                const encrypted = await crypto.subtle.encrypt(
                    { name: "AES-GCM", iv: iv },
                    roomKey,
                    encoded
                );

                const combined = new Uint8Array(iv.length + encrypted.byteLength);
                combined.set(iv, 0);
                combined.set(new Uint8Array(encrypted), iv.length);

                return btoa(String.fromCharCode(...combined));
            } catch (error) {
                return null;
            }
        }

        async function decryptMessage(encryptedData) {
            try {
                if (!roomKey) return null;

                const combined = Uint8Array.from(atob(encryptedData), c => c.charCodeAt(0));
                
                const iv = combined.slice(0, 12);
                const encrypted = combined.slice(12);
                
                const decrypted = await crypto.subtle.decrypt(
                    { name: "AES-GCM", iv: iv },
                    roomKey,
                    encrypted
                );

                const decoder = new TextDecoder();
                return decoder.decode(decrypted);
            } catch (error) {
                return null;
            }
        }

        function setUsername() {
            const usernameInput = document.getElementById('usernameInput');
            const randomName = userNames[Math.floor(Math.random() * userNames.length)] + '_' + (Math.floor(Math.random() * 99) + 1);
            myUsername = usernameInput.value.trim() || randomName;
            userUID = generateRandomUserID();
        }

        function generateRoomId() {
            return Math.random().toString(36).substring(2, 8).toUpperCase();
        }

        async function checkRoomExists(roomId) {
            const database = firebase.database();
            const roomRef = database.ref('rooms/' + roomId);
            const snapshot = await roomRef.once('value');
            return snapshot.exists();
        }

        async function createRoom() {
            if (!currentMode) {
                alert('Please select a mode first');
                return;
            }
            
            setUsername();
            
            if (currentMode === 'firebase') {
                if (!await ensureAuthentication()) return;
                
                let roomId = generateRoomId();
                let attempts = 0;
                
                while (await checkRoomExists(roomId) && attempts < 5) {
                    roomId = generateRoomId();
                    attempts++;
                }
                
                if (attempts >= 5) {
                    alert('Unable to create unique room. Please try again.');
                    return;
                }
                
                roomKey = await generateRoomKey();
                if (!roomKey) {
                    alert('Failed to generate encryption key');
                    return;
                }
                
                const exportedKey = await exportKey(roomKey);
                
                currentRoom = roomId;
                document.getElementById('roomCodeDisplay').textContent = currentRoom;
                document.getElementById('sessionCreated').classList.remove('hidden');
                document.getElementById('joinForm').classList.add('hidden');
                document.getElementById('p2pNotification').classList.add('hidden');
                
                const database = firebase.database();
                const roomSetupRef = database.ref('rooms/' + currentRoom);
                await roomSetupRef.child('roomKey').set(exportedKey);
                await roomSetupRef.child('createdAt').set(Date.now());
                await roomSetupRef.child('mode').set('firebase');
                
            } else if (currentMode === 'p2p') {
                if (!await ensureAuthentication()) {
                    alert('Cannot create P2P room: Firebase auth failed');
                    return;
                }
                
                const roomId = generateRoomId();
                currentRoom = roomId;
                
                const database = firebase.database();
                const roomSetupRef = database.ref('p2p_signaling/' + currentRoom);
                
                await roomSetupRef.set({
                    createdAt: Date.now(),
                    mode: 'p2p',
                    creator: userUID,
                    creatorUsername: myUsername,
                    offer: null,
                    answer: null,
                    iceCandidates: {},
                    destroySignal: null
                });
                
                await setupP2PConnection(true);
                enterChat();
            }
        }

        function showJoinForm() {
            if (!currentMode) {
                alert('Please select a mode first');
                return;
            }
            
            setUsername();
            document.getElementById('joinForm').classList.remove('hidden');
        }

        async function joinRoom() {
            if (!currentMode) {
                alert('Please select a mode first');
                return;
            }
            
            setUsername();
            const roomCode = document.getElementById('roomCodeInput').value.trim().toUpperCase();
            
            if (roomCode.length === 6) {
                currentRoom = roomCode;
                
                if (currentMode === 'firebase') {
                    if (!await ensureAuthentication()) return;
                    
                    const database = firebase.database();
                    const checkRoom = database.ref('rooms/' + roomCode);
                    const snapshot = await checkRoom.once('value');
                    
                    if (!snapshot.exists()) {
                        alert('Secure channel does not exist');
                        return;
                    }
                    
                    const roomData = snapshot.val();
                    if (roomData.roomKey) {
                        roomKey = await importKey(roomData.roomKey);
                    }
                    
                    document.getElementById('sessionCreated').classList.remove('hidden');
                    document.getElementById('roomCodeDisplay').textContent = currentRoom;
                    document.getElementById('p2pNotification').classList.add('hidden');
                    
                } else if (currentMode === 'p2p') {
                    if (!await ensureAuthentication()) {
                        alert('Cannot join P2P room: Firebase auth failed');
                        return;
                    }
                    
                    const database = firebase.database();
                    const checkRoom = database.ref('p2p_signaling/' + roomCode);
                    const snapshot = await checkRoom.once('value');
                    
                    if (!snapshot.exists()) {
                        alert('P2P channel does not exist');
                        return;
                    }
                    
                    const roomData = snapshot.val();
                    remoteUsername = roomData.creatorUsername || 'anonymous';
                    
                    await setupP2PConnection(false);
                    showP2PConnecting();
                    
                    setTimeout(() => {
                        if (p2pConnected) {
                            hideP2PConnecting();
                            enterChat();
                        } else {
                            hideP2PConnecting();
                            alert('Failed to establish P2P connection. Please try again.');
                        }
                    }, 5000);
                }
                
            } else {
                alert('Please enter a valid 6-digit access code');
            }
        }

        async function setupP2PConnection(isInitiator) {
            if (!currentRoom) {
                alert('Room not selected');
                return;
            }
            
            isP2PInitiator = isInitiator;
            
            const database = firebase.database();
            const signalingRef = database.ref('p2p_signaling/' + currentRoom);
            
            p2pSignalingRef = signalingRef;
            p2pIceCandidatesRef = signalingRef.child('iceCandidates');
            p2pOfferRef = signalingRef.child('offer');
            p2pAnswerRef = signalingRef.child('answer');
            p2pDestroyRef = signalingRef.child('destroySignal');
            
            const iceServers = [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' },
                { urls: 'stun:stun2.l.google.com:19302' },
                { urls: 'stun:stun3.l.google.com:19302' },
                { urls: 'stun:stun4.l.google.com:19302' }
            ];
            
            p2pConnection = new RTCPeerConnection({ 
                iceServers: iceServers,
                iceTransportPolicy: 'all',
                bundlePolicy: 'max-bundle',
                rtcpMuxPolicy: 'require'
            });
            
            p2pConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    const candidateData = {
                        candidate: event.candidate.candidate,
                        sdpMid: event.candidate.sdpMid,
                        sdpMLineIndex: event.candidate.sdpMLineIndex,
                        usernameFragment: event.candidate.usernameFragment
                    };
                    
                    p2pIceCandidatesRef.child(userUID).push(candidateData);
                }
            };
            
            p2pConnection.onicegatheringstatechange = () => {
                if (p2pConnection.iceGatheringState === 'complete') {
                }
            };
            
            p2pConnection.oniceconnectionstatechange = () => {
                const state = p2pConnection.iceConnectionState;
                if (state === 'connected' || state === 'completed') {
                    document.getElementById('connectionStatus').textContent = 'P2P CONNECTED';
                    p2pConnected = true;
                    
                    if (p2pDataChannel && p2pDataChannel.readyState === 'open') {
                        deleteP2PSignaling();
                    }
                } else if (state === 'disconnected' || state === 'failed' || state === 'closed') {
                    document.getElementById('connectionStatus').textContent = 'P2P DISCONNECTED';
                    p2pConnected = false;
                }
            };
            
            p2pConnection.onconnectionstatechange = () => {
                if (p2pConnection.connectionState === 'disconnected' ||
                    p2pConnection.connectionState === 'failed') {
                    if (!disconnectAnimationShown && !isDestroyAnimationActive) {
                        showDestroyAnimation();
                    }
                }
            };
            
            if (isInitiator) {
                p2pDataChannel = p2pConnection.createDataChannel('chat', {
                    ordered: true,
                    maxRetransmits: 3
                });
                setupDataChannel();
                
                const offer = await p2pConnection.createOffer({
                    offerToReceiveAudio: false,
                    offerToReceiveVideo: false,
                    iceRestart: false
                });
                
                await p2pConnection.setLocalDescription(offer);
                
                await p2pOfferRef.set({
                    sdp: offer.sdp,
                    type: offer.type,
                    from: userUID,
                    timestamp: Date.now()
                });
                
                p2pAnswerRef.on('value', async (snapshot) => {
                    if (snapshot.exists()) {
                        const answer = snapshot.val();
                        if (answer.from !== userUID && p2pConnection.signalingState !== 'stable') {
                            try {
                                await p2pConnection.setRemoteDescription(
                                    new RTCSessionDescription({
                                        type: answer.type,
                                        sdp: answer.sdp
                                    })
                                );
                            } catch (error) {}
                        }
                    }
                });
                
            } else {
                p2pConnection.ondatachannel = (event) => {
                    p2pDataChannel = event.channel;
                    setupDataChannel();
                };
                
                p2pOfferRef.on('value', async (snapshot) => {
                    if (snapshot.exists()) {
                        const offer = snapshot.val();
                        if (offer.from !== userUID && !p2pConnection.currentRemoteDescription) {
                            try {
                                await p2pConnection.setRemoteDescription(
                                    new RTCSessionDescription({
                                        type: offer.type,
                                        sdp: offer.sdp
                                    })
                                );
                                
                                const answer = await p2pConnection.createAnswer();
                                await p2pConnection.setLocalDescription(answer);
                                
                                await p2pAnswerRef.set({
                                    sdp: answer.sdp,
                                    type: answer.type,
                                    from: userUID,
                                    timestamp: Date.now()
                                });
                            } catch (error) {}
                        }
                    }
                });
            }
            
            p2pIceCandidatesRef.on('child_added', (snapshot) => {
                const userId = snapshot.key;
                if (userId === userUID) return;
                
                snapshot.ref.on('child_added', async (candidateSnapshot) => {
                    const candidateData = candidateSnapshot.val();
                    
                    try {
                        await p2pConnection.addIceCandidate(
                            new RTCIceCandidate({
                                candidate: candidateData.candidate,
                                sdpMid: candidateData.sdpMid,
                                sdpMLineIndex: candidateData.sdpMLineIndex,
                                usernameFragment: candidateData.usernameFragment
                            })
                        );
                    } catch (error) {}
                });
            });
            
            p2pDestroyRef.on('value', (snapshot) => {
                if (snapshot.exists() && !disconnectAnimationShown && !isDestroyAnimationActive) {
                    const destroyData = snapshot.val();
                    if (destroyData.timestamp && destroyData.initiator !== userUID) {
                        showDestroyAnimation();
                        setTimeout(() => {
                            destroyChat();
                        }, 100);
                    }
                }
            });
        }

        function setupDataChannel() {
            p2pDataChannel.onopen = () => {
                addSystemMessage('P2P connection established');
                document.getElementById('connectionStatus').textContent = 'P2P CONNECTED';
                p2pConnected = true;
                
                deleteP2PSignaling();
                
                const usersList = document.getElementById('usersList');
                usersList.innerHTML = '';
                
                const userTagLocal = document.createElement('div');
                userTagLocal.className = 'user-tag';
                userTagLocal.textContent = myUsername;
                userTagLocal.style.borderColor = 'var(--xmas-blue)';
                userTagLocal.style.background = 'rgba(30, 144, 255, 0.1)';
                usersList.appendChild(userTagLocal);
                
                const userTagRemote = document.createElement('div');
                userTagRemote.className = 'user-tag';
                userTagRemote.textContent = remoteUsername;
                usersList.appendChild(userTagRemote);
            };
            
            p2pDataChannel.onclose = () => {
                addSystemMessage('P2P connection closed');
                document.getElementById('connectionStatus').textContent = 'P2P DISCONNECTED';
                p2pConnected = false;
                
                if (!disconnectAnimationShown && !isDestroyAnimationActive) {
                    showDestroyAnimation();
                }
            };
            
            p2pDataChannel.onmessage = (event) => {
                try {
                    const message = JSON.parse(event.data);
                    addMessageWithDecryptAnimation(
                        message.content,
                        message.username,
                        false,
                        Date.now()
                    );
                } catch (error) {}
            };
            
            p2pDataChannel.onerror = (error) => {
            };
        }

        async function deleteP2PSignaling() {
            try {
                const database = firebase.database();
                const p2pRootRef = database.ref('p2p_signaling');
                await p2pRootRef.remove();
            } catch (error) {
            }
        }

        function copyRoomCode() {
            navigator.clipboard.writeText(currentRoom);
            alert('Access code copied to clipboard');
        }

        function enterChat() {
            hideP2PConnecting();
            
            document.getElementById('modeScreen').classList.add('hidden');
            document.getElementById('chatScreen').style.display = 'flex';
            
            const roomCodeElement = document.getElementById('currentRoomCode');
            roomCodeElement.textContent = currentRoom;
            
            let modeIndicator = '';
            if (currentMode === 'p2p') {
                modeIndicator = '<span class="connection-mode p2p">P2P</span>';
            } else {
                modeIndicator = '<span class="connection-mode firebase">FIREBASE</span>';
            }
            roomCodeElement.innerHTML = currentRoom + modeIndicator;
            
            document.getElementById('chatMessages').innerHTML = '';
            
            addSystemMessage('Secure connection established');
            if (currentMode === 'p2p') {
                addSystemMessage('P2P mode: Messages go directly between devices');
            } else {
                addSystemMessage('Channel will close when all users disconnect');
            }
            
            updateModeIndicator();
            
            if (currentMode === 'p2p') {
                
            } else {
                startFirebaseConnection();
            }
        }

        function startFirebaseConnection() {
            stopFirebaseListeners();
            
            const database = firebase.database();
            roomRef = database.ref('rooms/' + currentRoom);
            usersRef = roomRef.child('users');
            messagesRef = roomRef.child('messages');
            
            roomRef.child('createdAt').set(Date.now());
            
            const registerUser = async () => {
                const userData = {
                    lastSeen: Date.now(),
                    registeredAt: Date.now()
                };
                
                const encryptedUsername = await encryptMessage(myUsername);
                if (encryptedUsername) {
                    userData.encryptedUsername = encryptedUsername;
                }
                
                const userRef = usersRef.child(userUID);
                await userRef.set(userData);
                userRef.onDisconnect().remove();
            };
            
            registerUser();
            
            usersListener = usersRef.on('value', async (snapshot) => {
                const users = snapshot.val() || {};
                scheduleUsersUpdate(users);
            });
            
            messageListener = messagesRef.limitToLast(50).on('child_added', async (snapshot) => {
                const message = snapshot.val();
                if (message.userId !== userUID) {
                    const decryptedContent = await decryptMessage(message.encryptedContent);
                    let decryptedUsername = 'anonymous';
                    
                    if (message.encryptedUsername) {
                        decryptedUsername = await decryptMessage(message.encryptedUsername) || 'anonymous';
                    }
                    
                    if (decryptedContent) {
                        addMessageWithDecryptAnimation(decryptedContent, decryptedUsername, false, message.timestamp);
                    }
                }
            });

            destroyListener = roomRef.child('destroySignal').on('value', (snapshot) => {
                if (snapshot.exists() && !disconnectAnimationShown && !isDestroyAnimationActive) {
                    const destroyData = snapshot.val();
                    if (destroyData.timestamp && destroyData.initiator !== userUID) {
                        showDestroyAnimation();
                        setTimeout(() => {
                            destroyChat();
                        }, 100);
                    }
                }
            });

            roomRef.on('value', (snapshot) => {
                if (!snapshot.exists() && !disconnectAnimationShown && !isDestroyAnimationActive) {
                    showDestroyAnimation();
                }
            });

            startHeartbeat();
            startPeriodicRoomCheck();
            
            if (syncInterval) {
                clearInterval(syncInterval);
            }
            syncInterval = setInterval(forceUsersSync, 3000);
        }

        function forceUsersSync() {
            if (usersRef) {
                usersRef.once('value').then(async (snapshot) => {
                    const users = snapshot.val() || {};
                    scheduleUsersUpdate(users);
                });
            }
        }

        function startHeartbeat() {
            if (heartbeatInterval) {
                clearInterval(heartbeatInterval);
            }
            
            heartbeatInterval = setInterval(() => {
                if (usersRef && userUID) {
                    usersRef.child(userUID).update({
                        lastSeen: Date.now()
                    });
                }
            }, 5000);
        }

        function stopFirebaseListeners() {
            if (usersListener) {
                usersRef.off('value', usersListener);
                usersListener = null;
            }
            if (messageListener) {
                messagesRef.off('child_added', messageListener);
                messageListener = null;
            }
            if (destroyListener && roomRef) {
                roomRef.child('destroySignal').off('value', destroyListener);
                destroyListener = null;
            }
            if (roomRef) {
                roomRef.off();
            }
        }

        function stopP2PListeners() {
            if (p2pSignalingRef) {
                p2pSignalingRef.off();
                p2pSignalingRef = null;
            }
            if (p2pIceCandidatesRef) {
                p2pIceCandidatesRef.off();
                p2pIceCandidatesRef = null;
            }
            if (p2pOfferRef) {
                p2pOfferRef.off();
                p2pOfferRef = null;
            }
            if (p2pAnswerRef) {
                p2pAnswerRef.off();
                p2pAnswerRef = null;
            }
            if (p2pDestroyRef) {
                p2pDestroyRef.off();
                p2pDestroyRef = null;
            }
            if (p2pConnection) {
                p2pConnection.close();
                p2pConnection = null;
            }
            if (p2pDataChannel) {
                p2pDataChannel.close();
                p2pDataChannel = null;
            }
        }

        function scheduleUsersUpdate(users) {
            if (usersUpdateTimeout) {
                clearTimeout(usersUpdateTimeout);
            }
            usersUpdateTimeout = setTimeout(() => {
                updateUsersList(users);
            }, 500);
        }

        function startPeriodicRoomCheck() {
            if (roomCheckInterval) {
                clearInterval(roomCheckInterval);
            }
            
            roomCheckInterval = setInterval(() => {
                checkAndDeleteEmptyRoom();
            }, 5000);
        }

        async function checkAndDeleteEmptyRoom() {
            if (!roomRef) return;
            
            try {
                const usersSnapshot = await usersRef.once('value');
                const users = usersSnapshot.val() || {};
                
                if (Object.keys(users).length === 0) {
                    await roomRef.remove();
                    if (roomCheckInterval) {
                        clearInterval(roomCheckInterval);
                    }
                }
            } catch (error) {
            }
        }

        async function updateUsersList(users) {
            const usersList = document.getElementById('usersList');
            usersList.innerHTML = '';
            
            const now = Date.now();
            const timeout = 30000;
            
            const tempUsers = [];
            const seenUserIds = new Set();
            
            for (const userId in users) {
                if (seenUserIds.has(userId)) continue;
                seenUserIds.add(userId);
                
                const user = users[userId];
                
                if ((now - user.lastSeen) > timeout && userId !== userUID) {
                    continue;
                }
                
                let username = 'anonymous';
                
                if (user.encryptedUsername) {
                    try {
                        username = await decryptMessage(user.encryptedUsername) || 'anonymous';
                    } catch (e) {
                        username = 'anonymous';
                    }
                }
                
                tempUsers.push({
                    id: userId,
                    username: username,
                    lastSeen: user.lastSeen || now,
                    isCurrent: userId === userUID
                });
            }
            
            const activeUsers = tempUsers.filter(user => {
                return (now - user.lastSeen) <= timeout || user.isCurrent;
            });
            
            const uniqueUsers = activeUsers.filter((user, index, self) => 
                index === self.findIndex(u => u.id === user.id)
            );
            
            const sortedUsers = uniqueUsers.sort((a, b) => {
                if (a.isCurrent) return -1;
                if (b.isCurrent) return 1;
                return a.username.localeCompare(b.username);
            });
            
            sortedUsers.forEach(user => {
                const userTag = document.createElement('div');
                userTag.className = 'user-tag';
                userTag.textContent = user.username;
                
                if (user.isCurrent) {
                    userTag.style.borderColor = 'var(--xmas-blue)';
                    userTag.style.background = 'rgba(30, 144, 255, 0.1)';
                }
                
                usersList.appendChild(userTag);
            });
        }

        async function sendMessage() {
            const input = document.getElementById('messageInput');
            const message = input.value.trim();
            
            if (!message) return;
            
            if (currentMode === 'p2p') {
                if (p2pDataChannel && p2pDataChannel.readyState === 'open') {
                    const messageData = {
                        content: message,
                        username: myUsername,
                        timestamp: Date.now()
                    };
                    
                    p2pDataChannel.send(JSON.stringify(messageData));
                    addMessageWithDecryptAnimation(message, myUsername, true, Date.now());
                    input.value = '';
                    input.focus();
                } else {
                    alert('P2P connection not ready yet');
                }
                
            } else {
                const encryptedContent = await encryptMessage(message);
                const encryptedUsername = await encryptMessage(myUsername);
                
                if (!encryptedContent || !encryptedUsername) {
                    alert('Encryption failed');
                    return;
                }
                
                const messageData = {
                    encryptedContent: encryptedContent,
                    encryptedUsername: encryptedUsername,
                    userId: userUID,
                    timestamp: Date.now()
                };
                
                messagesRef.push(messageData);
                
                addMessageWithDecryptAnimation(message, myUsername, true, messageData.timestamp);
                input.value = '';
                input.focus();
            }
        }

        function addSystemMessage(content) {
            const messagesContainer = document.getElementById('chatMessages');
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message system';
            messageDiv.innerHTML = `<div class="message-content">[SYSTEM] ${content}</div>`;
            
            messagesContainer.appendChild(messageDiv);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

        function showDestroyAnimation() {
            if (isDestroyAnimationActive) return;
            isDestroyAnimationActive = true;
            
            const overlay = document.createElement('div');
            overlay.className = 'destroy-overlay';
            document.body.appendChild(overlay);
            
            const glitch = document.createElement('div');
            glitch.className = 'destroy-glitch';
            document.body.appendChild(glitch);
            
            const staticEffect = document.createElement('div');
            staticEffect.className = 'destroy-static';
            document.body.appendChild(staticEffect);
            
            const text = document.createElement('div');
            text.className = 'destroy-text';
            text.textContent = 'CONNECTION TERMINATED';
            document.body.appendChild(text);
            
            overlay.style.animation = 'destroyOverlay 1.5s ease-in-out forwards';
            glitch.style.animation = 'destroyGlitch 1.5s ease-in-out';
            staticEffect.style.animation = 'destroyStatic 1.5s ease-in-out';
            text.style.animation = 'destroyText 1.5s ease-in-out';
            
            setTimeout(() => {
                overlay.remove();
                glitch.remove();
                staticEffect.remove();
                text.remove();
                resetToMainScreen();
            }, 1500);
        }

        async function destroyChat() {
            if (disconnectAnimationShown) return;
            
            disconnectAnimationShown = true;
            showDestroyAnimation();
            
            if (currentMode === 'p2p') {
                if (p2pDestroyRef) {
                    await p2pDestroyRef.set({
                        timestamp: Date.now(),
                        initiator: userUID
                    });
                }
                
                stopP2PListeners();
                
                deleteP2PSignaling();
                
            } else {
                if (roomRef) {
                    await roomRef.child('destroySignal').set({
                        timestamp: Date.now(),
                        initiator: userUID
                    });
                    
                    stopFirebaseListeners();
                    
                    if (roomCheckInterval) {
                        clearInterval(roomCheckInterval);
                        roomCheckInterval = null;
                    }
                    
                    if (heartbeatInterval) {
                        clearInterval(heartbeatInterval);
                        heartbeatInterval = null;
                    }
                    
                    if (syncInterval) {
                        clearInterval(syncInterval);
                        syncInterval = null;
                    }
                    
                    if (usersUpdateTimeout) {
                        clearTimeout(usersUpdateTimeout);
                        usersUpdateTimeout = null;
                    }
                    
                    try {
                        if (usersRef && userUID) {
                            await usersRef.child(userUID).remove();
                        }
                        
                        await roomRef.remove();
                        
                    } catch (error) {
                    }
                }
            }
        }

        function resetToMainScreen() {
            stopFirebaseListeners();
            stopP2PListeners();
            
            if (roomCheckInterval) clearInterval(roomCheckInterval);
            if (heartbeatInterval) clearInterval(heartbeatInterval);
            if (syncInterval) clearInterval(syncInterval);
            if (usersUpdateTimeout) clearTimeout(usersUpdateTimeout);
            
            currentRoom = null;
            currentMode = null;
            roomRef = null;
            usersRef = null;
            messagesRef = null;
            roomKey = null;
            disconnectAnimationShown = false;
            isDestroyAnimationActive = false;
            p2pConnected = false;
            isP2PInitiator = false;
            remoteUsername = 'anonymous';
            
            document.getElementById('chatScreen').style.display = 'none';
            document.getElementById('modeScreen').classList.remove('hidden');
            document.getElementById('sessionCreated').classList.add('hidden');
            document.getElementById('joinForm').classList.add('hidden');
            document.getElementById('chatMessages').innerHTML = '';
            document.getElementById('p2pNotification').classList.add('hidden');
            
            document.getElementById('connectionStatus').textContent = 'CONNECTION SECURE';
            document.getElementById('connectionStatus').style.color = '';
        }

        document.addEventListener('DOMContentLoaded', function() {
            userUID = generateRandomUserID();
            
            document.getElementById('createRoomBtn').addEventListener('click', createRoom);
            document.getElementById('showJoinFormBtn').addEventListener('click', showJoinForm);
            document.getElementById('joinRoomBtn').addEventListener('click', joinRoom);
            document.getElementById('copyRoomCodeBtn').addEventListener('click', copyRoomCode);
            document.getElementById('enterChatBtn').addEventListener('click', enterChat);
            document.getElementById('sendMessageBtn').addEventListener('click', sendMessage);
            document.getElementById('destroyChatBtn').addEventListener('click', destroyChat);
            document.getElementById('deleteDecoyRoomsBtn').addEventListener('click', deleteDecoyRooms);
            document.getElementById('createFakeRoomsBtn').addEventListener('click', createFakeRooms);
            document.getElementById('deleteEmptyRoomsBtn').addEventListener('click', deleteEmptyRooms);

            document.getElementById('messageInput').addEventListener('keydown', function(e) {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    sendMessage();
                }
            });

            document.getElementById('roomCodeInput').addEventListener('keydown', function(e) {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    joinRoom();
                }
            });

            document.getElementById('usernameInput').addEventListener('keydown', function(e) {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    document.getElementById('roomCodeInput').focus();
                }
            });
            
            createTopGarland();
            
            setTimeout(() => {
                createSnowflakes();
                setInterval(() => {
                    createSingleSnowflake();
                }, 2500);
            }, 1000);
            
            setTimeout(() => {
                createAutoConfetti();
                setInterval(() => {
                    createAutoConfetti();
                }, 7000);
            }, 2000);
            
            setInterval(() => {
                cleanUpOldConfetti();
            }, 10000);
        });

        window.addEventListener('beforeunload', () => {
            if (xmasAnimationId) {
                cancelAnimationFrame(xmasAnimationId);
            }
            
            if (roomCheckInterval) {
                clearInterval(roomCheckInterval);
            }
            
            if (heartbeatInterval) {
                clearInterval(heartbeatInterval);
            }
            
            if (syncInterval) {
                clearInterval(syncInterval);
            }
            
            if (usersUpdateTimeout) {
                clearTimeout(usersUpdateTimeout);
            }
            
            if (decoyRoomManager.maintenanceInterval) {
                clearInterval(decoyRoomManager.maintenanceInterval);
            }
            
            stopAllNodes();
            stopP2PListeners();
            
            if (usersRef && userUID) {
                usersRef.child(userUID).remove();
            }
            
            activeConfetti.forEach(confetti => {
                if (confetti && confetti.parentNode) {
                    confetti.remove();
                }
            });
            activeConfetti = [];
            
            activeSnowflakes.forEach(snowflake => {
                if (snowflake && snowflake.parentNode) {
                    snowflake.remove();
                }
            });
            activeSnowflakes = [];
        });

        window.addEventListener('load', () => {
            initXmasCanvas();
            
            setTimeout(() => {
                document.getElementById('loadingScreen').style.display = 'none';
            }, 3500);
        });

        window.addEventListener('resize', () => {
            initXmasCanvas();
            document.getElementById('topGarland').innerHTML = '';
            createTopGarland();
        });

        document.addEventListener('touchstart', function() {}, {passive: true});
    </script>
</body>
</html>