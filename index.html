<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SHADOW NET | Secure Communications</title>
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjQiIGhlaWdodD0iNjQiIHZpZXdCb3g9IjAgMCA2NCA2NCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjY0IiBoZWlnaHQ9IjY0IiBmaWxsPSIjMGEwYTBhIi8+CjxjaXJjbGUgY3g9IjMyIiBjeT0iMjQiIHI9IjgiIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwZmY0MSIgc3Ryb2tlLXdpZHRoPSIyIi8+CjxjaXJjbGUgY3g9IjMyIiBjeT0iMjQiIHI9IjMiIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwZjdmZiIgc3Ryb2tlLXdpZHRoPSIxLjUiLz4KPHBhdGggZD0iTTE2IDQwQzE2IDM2IDIwIDMyIDMyIDMyczE2IDQgMTYgOHY4SDE2VjQwWiIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDBmZjQxIiBzdHJva2Utd2lkdGg9IjIiLz4KPGxpbmUgeDE9IjIwIiB5MT0iNTAiIHgyPSI0NCIgeTI9IjUwIiBzdHJva2U9IiMwMGZmNDEiIHN0cm9rZS13aWR0aD0iMiIvPgo8bGluZSB4MT0iMjQiIHkxPSI1NCIgeDI9IjQwIiB5Mj0iNTQiIHN0cm9rZT0iIzAwZmY0MSIgc3Ryb2tlLXdpZHRoPSIyIi8+Cjwvc3ZnPgo=">
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;600;700&family=Rajdhani:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
    <style>
        :root {
            --neon-green: #00ff41;
            --neon-blue: #00f7ff;
            --neon-purple: #bd00ff;
            --neon-cyan: #00ffd5;
            --dark-bg: #0a0a0a;
            --terminal-bg: #0d0d0d;
            --text-primary: #e0e0e0;
            --text-secondary: #8a8a8a;
            --success: #00ff41;
            --error: #ff003c;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        body {
            font-family: 'JetBrains Mono', monospace;
            background: var(--dark-bg);
            color: var(--text-primary);
            min-height: 100vh;
            overflow-x: hidden;
            -webkit-overflow-scrolling: touch;
        }

        #matrixRain {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -3;
            opacity: 0.1;
        }

        .hologram-layer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(45deg, transparent 30%, rgba(0, 255, 65, 0.01) 50%, transparent 70%);
            z-index: -2;
            animation: hologramMove 25s linear infinite;
        }

        @keyframes hologramMove {
            0% { transform: translateX(-100%) rotate(45deg); }
            100% { transform: translateX(100%) rotate(45deg); }
        }

        .quantum-field {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at 20% 80%, rgba(0, 255, 65, 0.03) 0%, transparent 50%),
                       radial-gradient(circle at 80% 20%, rgba(0, 247, 255, 0.03) 0%, transparent 50%);
            z-index: -2;
            animation: quantumPulse 12s ease-in-out infinite;
        }

        @keyframes quantumPulse {
            0%, 100% { opacity: 0.2; transform: scale(1); }
            50% { opacity: 0.4; transform: scale(1.05); }
        }

        .cyber-grid {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                linear-gradient(rgba(0, 255, 65, 0.02) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 255, 65, 0.02) 1px, transparent 1px);
            background-size: 60px 60px;
            z-index: -2;
            animation: gridPulse 15s ease-in-out infinite;
        }

        @keyframes gridPulse {
            0%, 100% { opacity: 0.2; }
            50% { opacity: 0.4; }
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0.5rem;
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .terminal {
            background: var(--terminal-bg);
            border: 1px solid rgba(0, 255, 65, 0.2);
            width: 100%;
            max-width: 900px;
            box-shadow: 
                0 0 60px rgba(0, 255, 65, 0.15),
                0 0 100px rgba(0, 247, 255, 0.08),
                inset 0 0 40px rgba(0, 255, 65, 0.03);
            position: relative;
            overflow: hidden;
            transition: all 0.4s ease;
        }

        .terminal:hover {
            box-shadow: 
                0 0 80px rgba(0, 255, 65, 0.2),
                0 0 120px rgba(0, 247, 255, 0.1),
                inset 0 0 60px rgba(0, 255, 65, 0.05);
        }

        .terminal::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, var(--neon-green), transparent);
            animation: terminalGlow 3s ease-in-out infinite;
        }

        @keyframes terminalGlow {
            0%, 100% { opacity: 0.2; }
            50% { opacity: 0.6; }
        }

        .terminal-header {
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.9) 0%, rgba(13, 13, 13, 0.95) 100%);
            padding: 1rem;
            border-bottom: 1px solid rgba(0, 255, 65, 0.15);
            display: flex;
            flex-direction: column;
            gap: 0.8rem;
            position: relative;
            overflow: hidden;
        }

        .terminal-header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, var(--neon-green), transparent);
            animation: headerScan 4s linear infinite;
        }

        @keyframes headerScan {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        .terminal-title {
            font-family: 'Rajdhani', sans-serif;
            font-size: 1.3rem;
            font-weight: 700;
            color: transparent;
            background: linear-gradient(45deg, var(--neon-green), var(--neon-cyan));
            -webkit-background-clip: text;
            background-clip: text;
            letter-spacing: 3px;
            text-align: center;
            text-shadow: 0 0 20px rgba(0, 255, 65, 0.3);
        }

        .terminal-status {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 1rem;
            flex-wrap: wrap;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 0.6rem;
            font-size: 0.75rem;
            padding: 0.4rem 0.8rem;
            background: rgba(0, 255, 65, 0.05);
            border: 1px solid rgba(0, 255, 65, 0.15);
            border-radius: 20px;
            transition: all 0.3s ease;
        }

        .status-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: var(--success);
            animation: pulse 3s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.6; transform: scale(1.1); }
        }

        .terminal-body {
            padding: 1rem;
            position: relative;
            display: flex;
            flex-direction: column;
            min-height: 400px;
        }

        .access-screen {
            text-align: center;
            position: relative;
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .logo {
            font-family: 'Rajdhani', sans-serif;
            font-size: 2.5rem;
            font-weight: 800;
            color: transparent;
            background: linear-gradient(45deg, var(--neon-green), var(--neon-blue), var(--neon-cyan));
            -webkit-background-clip: text;
            background-clip: text;
            margin-bottom: 1rem;
            letter-spacing: 4px;
            text-shadow: 
                0 0 20px rgba(0, 255, 65, 0.4),
                0 0 40px rgba(0, 247, 255, 0.2);
        }

        .tagline {
            font-size: 0.9rem;
            color: var(--neon-green);
            margin-bottom: 2rem;
            letter-spacing: 2px;
            text-transform: uppercase;
            position: relative;
            display: inline-block;
            animation: taglineGlow 4s ease-in-out infinite;
        }

        @keyframes taglineGlow {
            0%, 100% { 
                opacity: 1;
                filter: hue-rotate(0deg) brightness(1);
            }
            50% { 
                opacity: 0.8;
                filter: hue-rotate(90deg) brightness(1.3);
            }
        }

        .tagline::after {
            content: '';
            position: absolute;
            bottom: -8px;
            left: 25%;
            width: 50%;
            height: 1px;
            background: linear-gradient(90deg, transparent, var(--neon-green), transparent);
        }

        .access-code {
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.7) 0%, rgba(13, 13, 13, 0.8) 100%);
            border: 1px solid rgba(0, 255, 65, 0.2);
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-radius: 8px;
            position: relative;
            overflow: hidden;
        }

        .access-code::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(45deg, transparent 30%, rgba(0, 255, 65, 0.02) 50%, transparent 70%);
            animation: codeShine 8s linear infinite;
        }

        @keyframes codeShine {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        .code-display {
            font-size: 2rem;
            font-weight: 800;
            letter-spacing: 6px;
            color: var(--neon-green);
            margin: 1rem 0;
            font-family: 'JetBrains Mono', monospace;
            text-shadow: 0 0 15px rgba(0, 255, 65, 0.5);
        }

        .input-group {
            margin-bottom: 1.5rem;
            text-align: left;
            position: relative;
        }

        .input-label {
            display: block;
            margin-bottom: 0.6rem;
            color: var(--text-secondary);
            font-size: 0.8rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: 600;
        }

        .terminal-input {
            width: 100%;
            padding: 1rem;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.8) 0%, rgba(13, 13, 13, 0.9) 100%);
            border: 1px solid rgba(0, 255, 65, 0.2);
            color: var(--neon-green);
            font-family: 'JetBrains Mono', monospace;
            font-size: 1rem;
            transition: all 0.3s ease;
            border-radius: 6px;
            -webkit-appearance: none;
        }

        .terminal-input:focus {
            outline: none;
            border-color: var(--neon-green);
            box-shadow: 0 0 20px rgba(0, 255, 65, 0.2);
        }

        .terminal-input::placeholder {
            color: rgba(0, 255, 65, 0.3);
        }

        .btn-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            margin-top: 1.5rem;
        }

        .btn-group-full-width {
            grid-column: 1 / -1;
        }

        .terminal-btn {
            padding: 1.2rem 1.5rem;
            border: 1px solid rgba(0, 255, 65, 0.2);
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.8) 0%, rgba(13, 13, 13, 0.9) 100%);
            color: var(--neon-green);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 2px;
            position: relative;
            overflow: hidden;
            border-radius: 6px;
            user-select: none;
            -webkit-user-select: none;
            min-height: 50px;
            touch-action: manipulation;
        }

        .terminal-btn:active {
            transform: scale(0.98);
        }

        .terminal-btn.primary {
            background: linear-gradient(135deg, rgba(0, 255, 65, 0.12) 0%, rgba(0, 247, 255, 0.08) 100%);
            border-color: var(--neon-green);
        }

        .terminal-btn.danger {
            background: linear-gradient(135deg, rgba(255, 0, 60, 0.12) 0%, rgba(255, 0, 60, 0.08) 100%);
            border-color: var(--error);
            color: var(--error);
        }

        .terminal-btn.danger:active {
            transform: scale(0.95);
        }

        .chat-container {
            display: none;
            flex-direction: column;
            height: 65vh;
            position: relative;
            min-height: 500px;
        }

        .chat-header {
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.9) 0%, rgba(13, 13, 13, 0.95) 100%);
            padding: 1rem;
            border-bottom: 1px solid rgba(0, 255, 65, 0.15);
            position: relative;
            flex-shrink: 0;
        }

        .chat-header::before {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, var(--neon-green), transparent);
            animation: headerScan 4s linear infinite;
        }

        .chat-info {
            display: flex;
            flex-direction: column;
            gap: 0.8rem;
        }

        .room-code {
            font-size: 1.1rem;
            color: var(--neon-green);
            letter-spacing: 2px;
            text-align: center;
            font-weight: 700;
        }

        .chat-messages {
            flex: 1;
            padding: 1rem;
            overflow-y: auto;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.4) 0%, rgba(13, 13, 13, 0.6) 100%);
            display: flex;
            flex-direction: column;
            gap: 0.8rem;
            min-height: 200px;
            -webkit-overflow-scrolling: touch;
        }

        .message {
            padding: 0.8rem;
            border-left: 2px solid rgba(0, 255, 65, 0.4);
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.7) 0%, rgba(13, 13, 13, 0.8) 100%);
            animation: messageSlide 0.3s ease-out;
            word-break: break-word;
            border-radius: 0 6px 6px 0;
            font-size: 0.85rem;
        }

        @keyframes messageSlide {
            from { opacity: 0; transform: translateX(-20px); }
            to { opacity: 1; transform: translateX(0); }
        }

        .message.outgoing {
            border-left-color: var(--neon-blue);
            background: linear-gradient(135deg, rgba(0, 247, 255, 0.1) 0%, rgba(13, 13, 13, 0.8) 100%);
        }

        .message.incoming {
            border-left-color: var(--neon-purple);
            background: linear-gradient(135deg, rgba(189, 0, 255, 0.1) 0%, rgba(13, 13, 13, 0.8) 100%);
        }

        .message.system {
            border-left-color: var(--neon-green);
            background: linear-gradient(135deg, rgba(0, 255, 65, 0.08) 0%, rgba(13, 13, 13, 0.8) 100%);
        }

        .message-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.3rem;
            flex-wrap: wrap;
            gap: 0.3rem;
        }

        .message-sender {
            font-weight: 700;
            color: var(--neon-green);
            font-size: 0.8rem;
        }

        .message-time {
            font-size: 0.7rem;
            color: var(--text-secondary);
            font-weight: 500;
        }

        .message-content {
            font-size: 0.8rem;
            line-height: 1.3;
            color: var(--text-primary);
        }

        .decrypting-text {
            position: relative;
        }

        .decrypting-char {
            display: inline-block;
            color: var(--neon-cyan);
            animation: charDecrypt 0.1s ease-out forwards;
        }

        @keyframes charDecrypt {
            to {
                color: var(--text-primary);
            }
        }

        .chat-input-container {
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.9) 0%, rgba(13, 13, 13, 0.95) 100%);
            padding: 1rem;
            border-top: 1px solid rgba(0, 255, 65, 0.15);
            position: relative;
            flex-shrink: 0;
        }

        .chat-input-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, var(--neon-green), transparent);
            animation: headerScan 4s linear infinite;
        }

        .chat-input-group {
            display: flex;
            flex-direction: column;
            gap: 0.8rem;
        }

        .chat-input {
            flex: 1;
            padding: 0.8rem;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.8) 0%, rgba(13, 13, 13, 0.9) 100%);
            border: 1px solid rgba(0, 255, 65, 0.2);
            color: var(--neon-green);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9rem;
            border-radius: 6px;
            transition: all 0.3s ease;
            -webkit-appearance: none;
            min-height: 44px;
        }

        .chat-input:focus {
            outline: none;
            border-color: var(--neon-green);
            box-shadow: 0 0 20px rgba(0, 255, 65, 0.2);
        }

        .send-btn {
            padding: 0.8rem 1rem;
            background: linear-gradient(135deg, rgba(0, 255, 65, 0.12) 0%, rgba(0, 247, 255, 0.08) 100%);
            border: 1px solid var(--neon-green);
            color: var(--neon-green);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            border-radius: 6px;
            text-transform: uppercase;
            letter-spacing: 1px;
            user-select: none;
            -webkit-user-select: none;
            min-height: 44px;
            touch-action: manipulation;
        }

        .send-btn:active {
            transform: scale(0.95);
        }

        .users-panel {
            display: flex;
            gap: 0.6rem;
            margin-top: 0.8rem;
            flex-wrap: wrap;
            justify-content: center;
        }

        .user-tag {
            padding: 0.3rem 0.8rem;
            background: linear-gradient(135deg, rgba(0, 255, 65, 0.15) 0%, rgba(0, 255, 65, 0.08) 100%);
            border: 1px solid rgba(0, 255, 65, 0.4);
            font-size: 0.7rem;
            color: var(--neon-green);
            border-radius: 15px;
        }

        .hidden {
            display: none;
        }

        .danger-btn {
            background: linear-gradient(135deg, rgba(255, 0, 60, 0.12) 0%, rgba(255, 0, 60, 0.08) 100%);
            border-color: var(--error);
            color: var(--error);
        }

        .danger-btn:active {
            transform: scale(0.95);
        }

        .loading-terminal {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--terminal-bg);
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            z-index: 10;
        }

        .loading-text {
            color: var(--neon-green);
            font-size: 1.5rem;
            margin-bottom: 2rem;
            animation: welcomeGlow 3s ease-in-out infinite;
            font-weight: 800;
            letter-spacing: 3px;
            font-family: 'Rajdhani', sans-serif;
            text-align: center;
        }

        @keyframes welcomeGlow {
            0%, 100% { 
                opacity: 1; 
                filter: hue-rotate(0deg) brightness(1);
            }
            50% { 
                opacity: 0.8; 
                filter: hue-rotate(60deg) brightness(1.2);
            }
        }

        .progress-bar {
            width: 300px;
            height: 3px;
            background: rgba(0, 255, 65, 0.2);
            border-radius: 3px;
            overflow: hidden;
            position: relative;
        }

        .progress-bar::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            width: 100%;
            background: linear-gradient(90deg, transparent, rgba(0, 255, 65, 0.6), transparent);
            animation: progressShine 2s linear infinite;
        }

        .progress {
            height: 100%;
            background: linear-gradient(90deg, var(--neon-green), var(--neon-cyan));
            width: 0%;
            animation: progressLoad 3.5s ease-in-out;
        }

        @keyframes progressLoad {
            0% { width: 0%; }
            100% { width: 100%; }
        }

        @keyframes progressShine {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        .digital-watermark {
            position: fixed;
            bottom: 15px;
            right: 15px;
            color: rgba(0, 255, 65, 0.08);
            font-size: 0.6rem;
            font-family: 'JetBrains Mono', monospace;
            pointer-events: none;
            z-index: 1000;
        }

        .destroy-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000000;
            z-index: 10000;
            pointer-events: none;
            opacity: 0;
        }

        .destroy-glitch {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                repeating-linear-gradient(0deg, 
                    rgba(255, 255, 255, 0.03) 0px, 
                    rgba(255, 255, 255, 0.03) 1px, 
                    transparent 1px, 
                    transparent 2px
                );
            z-index: 10001;
            pointer-events: none;
            opacity: 0;
        }

        .destroy-static {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 20% 50%, rgba(255, 255, 255, 0.1) 0%, transparent 20%),
                radial-gradient(circle at 80% 20%, rgba(255, 255, 255, 0.08) 0%, transparent 20%);
            z-index: 10002;
            pointer-events: none;
            opacity: 0;
        }

        .destroy-text {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: var(--error);
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.5rem;
            font-weight: 800;
            text-align: center;
            z-index: 10003;
            opacity: 0;
            text-shadow: 0 0 15px rgba(255, 0, 60, 0.7);
        }

        @keyframes destroyOverlay {
            0% { opacity: 0; }
            20% { opacity: 0.8; background: #1a1a1a; }
            40% { opacity: 0.9; background: #2a2a2a; }
            60% { opacity: 0.95; background: #1a1a1a; }
            80% { opacity: 0.8; background: #0a0a0a; }
            100% { opacity: 1; background: #000000; }
        }

        @keyframes destroyGlitch {
            0% { opacity: 0; transform: translateY(-5px); }
            25% { opacity: 0.8; transform: translateY(3px); filter: hue-rotate(90deg); }
            50% { opacity: 0.4; transform: translateY(-2px); filter: hue-rotate(180deg); }
            75% { opacity: 0.9; transform: translateY(1px); filter: hue-rotate(270deg); }
            100% { opacity: 0; transform: translateY(0); filter: hue-rotate(0deg); }
        }

        @keyframes destroyStatic {
            0% { opacity: 0; filter: blur(0px); }
            33% { opacity: 0.6; filter: blur(1px); }
            66% { opacity: 0.8; filter: blur(2px); }
            100% { opacity: 0; filter: blur(0px); }
        }

        @keyframes destroyText {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
            30% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
            60% { opacity: 0.9; transform: translate(-50%, -50%) scale(1); }
            90% { opacity: 0.8; transform: translate(-50%, -50%) scale(0.95); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
        }

        @media (min-width: 768px) {
            .container { padding: 2rem; }
            .terminal-body { padding: 2rem; }
            .logo { font-size: 4rem; }
            .code-display { font-size: 3rem; letter-spacing: 10px; }
            .btn-group { grid-template-columns: 1fr 1fr; }
            .terminal-header { flex-direction: row; justify-content: space-between; align-items: center; }
            .chat-input-group { flex-direction: row; }
            .chat-info { flex-direction: row; justify-content: space-between; align-items: center; }
            .chat-container { height: 60vh; }
            .chat-messages { padding: 1.5rem; gap: 1rem; }
            .message { padding: 1rem; font-size: 0.9rem; }
        }

        @media (max-width: 480px) {
            .container { padding: 0.5rem; }
            .terminal-body { padding: 0.8rem; min-height: 300px; }
            .logo { font-size: 2rem; }
            .code-display { font-size: 1.5rem; letter-spacing: 4px; }
            .chat-container { height: calc(100vh - 140px); min-height: 400px; }
            .loading-text { font-size: 1.2rem; }
            .progress-bar { width: 250px; }
            .terminal-btn { padding: 1rem 1.2rem; font-size: 0.8rem; min-height: 50px; }
            .chat-input-group { gap: 0.6rem; }
            .send-btn { padding: 0.8rem 0.9rem; font-size: 0.75rem; min-height: 44px; }
            .chat-input { font-size: 16px; }
            .terminal-input { font-size: 16px; }
            .message { padding: 0.6rem; font-size: 0.8rem; }
            .users-panel { gap: 0.4rem; }
            .user-tag { padding: 0.2rem 0.6rem; font-size: 0.65rem; }
            .btn-group { gap: 0.8rem; }
        }

        @media (max-width: 360px) {
            .logo { font-size: 1.8rem; }
            .terminal-title { font-size: 1.1rem; }
            .status-indicator { font-size: 0.7rem; padding: 0.3rem 0.6rem; }
            .chat-container { height: calc(100vh - 120px); min-height: 350px; }
            .terminal-btn { padding: 0.8rem 1rem; }
            .terminal-body { min-height: 280px; }
            .chat-input-container { padding: 0.8rem; }
        }

        @media (max-height: 600px) {
            .chat-container { height: calc(100vh - 100px); min-height: 300px; }
            .terminal-body { padding: 0.5rem; min-height: 250px; }
            .chat-messages { padding: 0.5rem; gap: 0.5rem; }
            .message { padding: 0.5rem; font-size: 0.75rem; }
            .logo { font-size: 1.8rem; margin-bottom: 0.5rem; }
            .tagline { margin-bottom: 1rem; }
            .chat-input-container { padding: 0.6rem; }
        }

        @media (max-height: 500px) {
            .terminal-body { min-height: 200px; }
            .chat-container { min-height: 250px; }
            .logo { font-size: 1.5rem; }
            .tagline { font-size: 0.8rem; }
            .btn-group { margin-top: 1rem; gap: 0.6rem; }
            .terminal-btn { padding: 0.7rem 0.9rem; min-height: 45px; }
            .chat-input-container { padding: 0.5rem; }
            .chat-input-group { gap: 0.5rem; }
        }

        @media (max-height: 400px) {
            .chat-container { height: calc(100vh - 80px); min-height: 200px; }
            .terminal-body { min-height: 180px; padding: 0.3rem; }
            .chat-messages { padding: 0.3rem; gap: 0.3rem; min-height: 120px; }
            .message { padding: 0.4rem; font-size: 0.7rem; }
            .chat-header { padding: 0.6rem; }
            .chat-input-container { padding: 0.4rem; }
            .send-btn { padding: 0.6rem 0.8rem; font-size: 0.7rem; min-height: 40px; }
            .chat-input { padding: 0.6rem; font-size: 0.8rem; min-height: 40px; }
        }
    </style>
</head>
<body>
    <canvas id="matrixRain"></canvas>
    <div class="hologram-layer"></div>
    <div class="quantum-field"></div>
    <div class="cyber-grid"></div>
    <div class="digital-watermark">SHADOW_NET_v4.2.7_ENC_256BIT</div>

    <div class="container">
        <div class="terminal">
            <div class="loading-terminal" id="loadingScreen">
                <div class="loading-text">WELCOME TO SHADOW NET</div>
                <div class="progress-bar">
                    <div class="progress"></div>
                </div>
            </div>

            <div class="terminal-header">
                <div class="terminal-title">SHADOW NET</div>
                <div class="terminal-status">
                    <div class="status-indicator">
                        <div class="status-dot"></div>
                        <span>ENCRYPTION ACTIVE</span>
                    </div>
                    <div class="status-indicator">
                        <div class="status-dot" style="background: var(--neon-blue);"></div>
                        <span>NETWORK SYNC</span>
                    </div>
                </div>
            </div>

            <div class="terminal-body">
                <div id="accessScreen" class="access-screen">
                    <div class="logo">SHADOW NET</div>
                    <div class="tagline">QUANTUM SECURE COMMUNICATIONS</div>
                    
                    <div class="input-group">
                        <label class="input-label">DIGITAL IDENTITY (OPTIONAL)</label>
                        <input type="text" class="terminal-input" id="usernameInput" placeholder="anonymous">
                    </div>

                    <div class="btn-group">
                        <button class="terminal-btn primary" id="createRoomBtn">CREATE SESSION</button>
                        <button class="terminal-btn" id="showJoinFormBtn">JOIN SESSION</button>
                        <button class="terminal-btn danger" id="deleteDecoyRoomsBtn">DELETE DECOY ROOMS</button>
                        <button class="terminal-btn" id="createFakeRoomsBtn">CREATE DECOY ROOMS</button>
                        <button class="terminal-btn danger btn-group-full-width" id="deleteEmptyRoomsBtn">DELETE EMPTY ROOMS</button>
                    </div>

                    <div id="joinForm" class="hidden">
                        <div class="input-group">
                            <label class="input-label">ACCESS CODE</label>
                            <input type="text" class="terminal-input" id="roomCodeInput" placeholder="ENTER 6-DIGIT CRYPTO-CODE">
                        </div>
                        <button class="terminal-btn primary" id="joinRoomBtn">ESTABLISH CONNECTION</button>
                    </div>

                    <div id="sessionCreated" class="hidden">
                        <div class="access-code">
                            <div class="input-label">SESSION ACCESS CODE</div>
                            <div class="code-display" id="roomCodeDisplay"></div>
                            <button class="terminal-btn" id="copyRoomCodeBtn">COPY CRYPTO-CODE</button>
                        </div>
                        <button class="terminal-btn primary" id="enterChatBtn">ENTER SECURE CHAT</button>
                    </div>
                </div>

                <div class="chat-container" id="chatScreen">
                    <div class="chat-header">
                        <div class="chat-info">
                            <div>
                                <div style="font-size: 0.8rem; color: var(--text-secondary);">ACTIVE SESSION</div>
                                <div class="room-code" id="currentRoomCode"></div>
                            </div>
                            <div class="status-indicator">
                                <div class="status-dot"></div>
                                <span>CONNECTION SECURE</span>
                            </div>
                        </div>
                        <div class="users-panel" id="usersList"></div>
                    </div>

                    <div class="chat-messages" id="chatMessages"></div>

                    <div class="chat-input-container">
                        <div class="chat-input-group">
                            <input type="text" class="chat-input" id="messageInput" placeholder="TRANSMIT ENCRYPTED MESSAGE...">
                            <button class="send-btn" id="sendMessageBtn">SEND</button>
                            <button class="send-btn danger-btn" id="destroyChatBtn">DESTROY CHAT</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const firebaseConfig = {
            apiKey: "AIzaSyDrY5azkfFacBNQ36ok8O7eMKQGPTH9Xs4",
            authDomain: "shadow-net-chat.firebaseapp.com",
            databaseURL: "https://shadow-net-chat-default-rtdb.firebaseio.com",
            projectId: "shadow-net-chat",
            storageBucket: "shadow-net-chat.firebasestorage.app",
            messagingSenderId: "477144065218",
            appId: "1:477144065218:web:a27ed2f1f92727f8e7475b"
        };

        firebase.initializeApp(firebaseConfig);

        let currentRoom = null;
        let currentUser = null;
        let roomRef = null;
        let usersRef = null;
        let messagesRef = null;
        let myUsername = 'anonymous';
        let disconnectAnimationShown = false;
        let userUID = null;
        let roomKey = null;
        let matrixAnimationId = null;
        let isAuthenticated = false;
        let roomCheckInterval = null;
        let messageListener = null;
        let usersListener = null;
        let heartbeatInterval = null;
        let userSessionId = null;
        let syncInterval = null;
        let usersUpdateTimeout = null;
        let destroyListener = null;
        let decoyRoomManager = {
            targetCount: 0,
            activeRooms: new Set(),
            nodeIntervals: new Map(),
            maintenanceInterval: null,
            isActive: false
        };

        const matrixChars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789$#@%&*";
        const matrixCanvas = document.getElementById('matrixRain');
        const ctx = matrixCanvas.getContext('2d');
        let matrixDrops = [];

        const nodeMessages = [
            "Traffic intercepted from segment 7B",
            "AES-256 encryption active",
            "Channel secure for transmission",
            "Port scanning detected",
            "Ghost protocol activated",
            "Node synchronization complete",
            "Traffic masked successfully",
            "Suspicious packets detected",
            "Quantum protocol active",
            "Routing through shadow core",
            "DDoS protection active",
            "End-to-end encryption established",
            "Channel ready for data transfer",
            "Network monitoring active",
            "All systems operational"
        ];

        const userNames = [
            "ghost", "phantom", "shadow", "raven", "wolf", "viper", "hawk", "falcon",
            "specter", "wraith", "hunter", "ranger", "sentinel", "guardian", "watcher",
            "strider", "nomad", "voyager", "pioneer", "explorer", "operative", "agent",
            "cypher", "nexus", "vector", "quantum", "neural", "digital", "crypto",
            "stealth", "silent", "covert", "hidden", "unknown", "mystery", "enigma"
        ];

        function initMatrixRain() {
            if (matrixAnimationId) {
                cancelAnimationFrame(matrixAnimationId);
            }
            
            matrixCanvas.width = window.innerWidth;
            matrixCanvas.height = window.innerHeight;
            
            const fontSize = 14;
            const columns = matrixCanvas.width / fontSize;
            
            matrixDrops = [];
            for (let i = 0; i < columns; i++) {
                matrixDrops[i] = {
                    x: i * fontSize,
                    y: Math.random() * -matrixCanvas.height,
                    speed: Math.random() * 1.5 + 0.5,
                    char: matrixChars.charAt(Math.floor(Math.random() * matrixChars.length))
                };
            }
            
            animateMatrixRain();
        }

        function animateMatrixRain() {
            ctx.fillStyle = 'rgba(10, 10, 10, 0.03)';
            ctx.fillRect(0, 0, matrixCanvas.width, matrixCanvas.height);
            
            ctx.fillStyle = '#00ff41';
            ctx.font = '14px JetBrains Mono';
            
            matrixDrops.forEach((drop, i) => {
                ctx.fillText(drop.char, drop.x, drop.y);
                
                drop.y += drop.speed;
                if (drop.y > matrixCanvas.height) {
                    drop.y = Math.random() * -50;
                    drop.char = matrixChars.charAt(Math.floor(Math.random() * matrixChars.length));
                }
            });
            
            matrixAnimationId = requestAnimationFrame(animateMatrixRain);
        }

        function generateRandomUserID() {
            const timestamp = Date.now().toString(36);
            const randomPart = Math.random().toString(36).substr(2, 12);
            return timestamp + '_' + randomPart;
        }

        async function ensureAuthentication() {
            if (isAuthenticated) return true;
            
            try {
                await firebase.auth().signOut();
                const userCredential = await firebase.auth().signInAnonymously();
                currentUser = userCredential.user;
                isAuthenticated = true;
                return true;
            } catch (error) {
                return false;
            }
        }

        async function getRoomStats() {
            try {
                const database = firebase.database();
                const roomsRef = database.ref('rooms');
                const snapshot = await roomsRef.once('value');
                const rooms = snapshot.val() || {};
                
                const totalRooms = Object.keys(rooms).length;
                let decoyRooms = 0;
                
                for (const roomId in rooms) {
                    if (rooms[roomId] && rooms[roomId].s_arch === true) {
                        decoyRooms++;
                    }
                }
                
                return { totalRooms, decoyRooms };
            } catch (error) {
                return { totalRooms: 0, decoyRooms: 0 };
            }
        }

        async function deleteEmptyRooms() {
            try {
                if (!await ensureAuthentication()) return;
                
                const database = firebase.database();
                const roomsRef = database.ref('rooms');
                const snapshot = await roomsRef.once('value');
                const rooms = snapshot.val() || {};
                
                let emptyRooms = [];
                let deletePromises = [];
                
                for (const roomId in rooms) {
                    const room = rooms[roomId];
                    if (room && room.users) {
                        const users = room.users;
                        if (Object.keys(users).length === 0) {
                            emptyRooms.push(roomId);
                            deletePromises.push(roomsRef.child(roomId).remove());
                        }
                    } else if (room && !room.s_arch) {
                        emptyRooms.push(roomId);
                        deletePromises.push(roomsRef.child(roomId).remove());
                    }
                }
                
                if (emptyRooms.length === 0) {
                    alert('No empty rooms found');
                    return;
                }
                
                await Promise.all(deletePromises);
                
                alert(`Deleted ${emptyRooms.length} empty rooms`);
                
            } catch (error) {
            }
        }

        function stopAllDecoyProcesses() {
            decoyRoomManager.isActive = false;
            decoyRoomManager.targetCount = 0;
            
            if (decoyRoomManager.maintenanceInterval) {
                clearInterval(decoyRoomManager.maintenanceInterval);
                decoyRoomManager.maintenanceInterval = null;
            }
            
            stopAllNodes();
        }

        async function stopAllNodes() {
            for (const [roomId, interval] of decoyRoomManager.nodeIntervals) {
                clearInterval(interval);
            }
            decoyRoomManager.nodeIntervals.clear();
        }

        async function deleteDecoyRooms() {
            try {
                if (!await ensureAuthentication()) return;
                
                const stats = await getRoomStats();
                
                if (stats.decoyRooms === 0) {
                    alert('No decoy rooms found');
                    return;
                }
                
                if (!confirm(`WARNING: This will delete ${stats.decoyRooms} decoy rooms.\nContinue?`)) {
                    return;
                }
                
                stopAllDecoyProcesses();
                
                const database = firebase.database();
                const roomsRef = database.ref('rooms');
                const snapshot = await roomsRef.once('value');
                const rooms = snapshot.val() || {};
                
                let deleteCount = 0;
                const decoyRooms = [];
                
                for (const roomId in rooms) {
                    const room = rooms[roomId];
                    if (room && room.s_arch === true) {
                        decoyRooms.push(roomId);
                    }
                }
                
                for (let i = 0; i < decoyRooms.length; i++) {
                    const roomId = decoyRooms[i];
                    setTimeout(async () => {
                        try {
                            await roomsRef.child(roomId).remove();
                            decoyRoomManager.activeRooms.delete(roomId);
                            deleteCount++;
                            
                            if (deleteCount === decoyRooms.length) {
                                alert(`Deleted ${deleteCount} decoy rooms`);
                            }
                        } catch (error) {
                        }
                    }, Math.random() * 3000 + 1000);
                }
                
            } catch (error) {
            }
        }

        async function createFakeRooms() {
            try {
                if (!await ensureAuthentication()) return;
                
                const roomCount = Math.floor(Math.random() * 21) + 10;
                
                if (!confirm(`Create ${roomCount} decoy rooms?`)) {
                    return;
                }
                
                decoyRoomManager.targetCount = roomCount;
                decoyRoomManager.isActive = true;
                
                await createDecoyRoomsWithDelay(roomCount);
                
                startDecoyRoomMaintenance();
                
            } catch (error) {
            }
        }

        async function createDecoyRoomsWithDelay(totalCount) {
            if (!decoyRoomManager.isActive) return;
            
            const database = firebase.database();
            const roomsRef = database.ref('rooms');
            
            let createdCount = 0;
            
            const createRoomWithDelay = async (index) => {
                if (index >= totalCount || !decoyRoomManager.isActive) return;
                
                const delay = Math.random() * 1200 + 300;
                
                setTimeout(async () => {
                    try {
                        const roomId = generateRoomId();
                        const roomKey = await generateRoomKey();
                        if (!roomKey) return;
                        
                        const exportedKey = await exportKey(roomKey);
                        
                        await roomsRef.child(roomId).set({
                            roomKey: exportedKey,
                            createdAt: Date.now(),
                            s_arch: true
                        });
                        
                        decoyRoomManager.activeRooms.add(roomId);
                        await addUsersToRoom(roomId, roomKey);
                        createdCount++;
                        
                        createRoomWithDelay(index + 1);
                        
                    } catch (error) {
                        createRoomWithDelay(index + 1);
                    }
                }, delay);
            };
            
            createRoomWithDelay(0);
        }

        async function addUsersToRoom(roomId, roomKey) {
            if (!decoyRoomManager.isActive) return;
            
            const userCount = Math.floor(Math.random() * 5) + 1;
            const database = firebase.database();
            const roomRef = database.ref('rooms/' + roomId);
            
            for (let i = 0; i < userCount; i++) {
                const userId = generateRandomUserID();
                const randomUsername = userNames[Math.floor(Math.random() * userNames.length)] + '_' + (Math.floor(Math.random() * 99) + 1);
                const encryptedUsername = await encryptMessageWithKey(randomUsername, roomKey);
                
                if (encryptedUsername) {
                    await roomRef.child('users').child(userId).set({
                        encryptedUsername: encryptedUsername,
                        lastSeen: Date.now(),
                        node: true
                    });
                }
            }
            
            const nodeInterval = setInterval(async () => {
                if (!decoyRoomManager.isActive) {
                    clearInterval(nodeInterval);
                    return;
                }
                
                const roomCheck = await roomRef.once('value');
                if (!roomCheck.exists()) {
                    clearInterval(nodeInterval);
                    decoyRoomManager.nodeIntervals.delete(roomId);
                    return;
                }
                
                if (Math.random() > 0.3) {
                    const message = nodeMessages[Math.floor(Math.random() * nodeMessages.length)];
                    const encryptedContent = await encryptMessageWithKey(message, roomKey);
                    const randomUsername = userNames[Math.floor(Math.random() * userNames.length)] + '_' + (Math.floor(Math.random() * 99) + 1);
                    const encryptedUsername = await encryptMessageWithKey(randomUsername, roomKey);
                    
                    if (encryptedContent && encryptedUsername) {
                        await roomRef.child('messages').push({
                            encryptedContent: encryptedContent,
                            encryptedUsername: encryptedUsername,
                            userId: generateRandomUserID(),
                            timestamp: Date.now(),
                            node: true
                        });
                    }
                }
            }, Math.random() * 20000 + 10000);
            
            decoyRoomManager.nodeIntervals.set(roomId, nodeInterval);
        }

        function startDecoyRoomMaintenance() {
            if (decoyRoomManager.maintenanceInterval) {
                clearInterval(decoyRoomManager.maintenanceInterval);
            }
            
            decoyRoomManager.maintenanceInterval = setInterval(async () => {
                if (!decoyRoomManager.isActive) return;
                
                const currentStats = await getRoomStats();
                const currentDecoyCount = currentStats.decoyRooms;
                
                if (currentDecoyCount < decoyRoomManager.targetCount) {
                    const needed = decoyRoomManager.targetCount - currentDecoyCount;
                    await createAdditionalDecoyRooms(needed);
                } else if (currentDecoyCount > decoyRoomManager.targetCount) {
                    const excess = currentDecoyCount - decoyRoomManager.targetCount;
                    await removeExcessDecoyRooms(excess);
                }
                
                await randomlyRefreshRooms();
                
            }, 30000);
        }

        async function createAdditionalDecoyRooms(count) {
            if (count <= 0 || !decoyRoomManager.isActive) return;
            
            const database = firebase.database();
            const roomsRef = database.ref('rooms');
            
            for (let i = 0; i < count; i++) {
                try {
                    const roomId = generateRoomId();
                    if (decoyRoomManager.activeRooms.has(roomId)) continue;
                    
                    const roomKey = await generateRoomKey();
                    if (!roomKey) continue;
                    
                    const exportedKey = await exportKey(roomKey);
                    
                    await roomsRef.child(roomId).set({
                        roomKey: exportedKey,
                        createdAt: Date.now(),
                        s_arch: true
                    });
                    
                    decoyRoomManager.activeRooms.add(roomId);
                    await addUsersToRoom(roomId, roomKey);
                    
                } catch (error) {
                }
            }
        }

        async function removeExcessDecoyRooms(count) {
            if (count <= 0 || !decoyRoomManager.isActive) return;
            
            const database = firebase.database();
            const roomsRef = database.ref('rooms');
            const snapshot = await roomsRef.once('value');
            const rooms = snapshot.val() || {};
            
            let removed = 0;
            const roomIds = Object.keys(rooms);
            
            for (const roomId of roomIds) {
                if (removed >= count) break;
                
                const room = rooms[roomId];
                if (room && room.s_arch === true && decoyRoomManager.activeRooms.has(roomId)) {
                    if (decoyRoomManager.nodeIntervals.has(roomId)) {
                        clearInterval(decoyRoomManager.nodeIntervals.get(roomId));
                        decoyRoomManager.nodeIntervals.delete(roomId);
                    }
                    
                    await roomsRef.child(roomId).remove();
                    decoyRoomManager.activeRooms.delete(roomId);
                    removed++;
                }
            }
        }

        async function randomlyRefreshRooms() {
            if (decoyRoomManager.activeRooms.size === 0 || !decoyRoomManager.isActive) return;
            
            const refreshChance = 0.5;
            if (Math.random() > refreshChance) return;
            
            const roomsToRefresh = Math.floor(Math.random() * 5) + 2;
            const roomArray = Array.from(decoyRoomManager.activeRooms);
            
            for (let i = 0; i < roomsToRefresh && i < roomArray.length; i++) {
                const roomId = roomArray[Math.floor(Math.random() * roomArray.length)];
                await refreshDecoyRoom(roomId);
            }
        }

        async function refreshDecoyRoom(roomId) {
            if (!decoyRoomManager.isActive) return;
            
            const database = firebase.database();
            const roomRef = database.ref('rooms/' + roomId);
            
            if (decoyRoomManager.nodeIntervals.has(roomId)) {
                clearInterval(decoyRoomManager.nodeIntervals.get(roomId));
                decoyRoomManager.nodeIntervals.delete(roomId);
            }
            
            await roomRef.remove();
            decoyRoomManager.activeRooms.delete(roomId);
            
            setTimeout(async () => {
                if (!decoyRoomManager.isActive) return;
                
                const newRoomId = generateRoomId();
                const roomKey = await generateRoomKey();
                if (!roomKey) return;
                
                const exportedKey = await exportKey(roomKey);
                
                await database.ref('rooms').child(newRoomId).set({
                    roomKey: exportedKey,
                    createdAt: Date.now(),
                    s_arch: true
                });
                
                decoyRoomManager.activeRooms.add(newRoomId);
                await addUsersToRoom(newRoomId, roomKey);
                
            }, Math.random() * 15000);
        }

        async function encryptMessageWithKey(message, key) {
            try {
                const encoder = new TextEncoder();
                const encoded = encoder.encode(message);
                
                const iv = crypto.getRandomValues(new Uint8Array(12));
                
                const encrypted = await crypto.subtle.encrypt(
                    { name: "AES-GCM", iv: iv },
                    key,
                    encoded
                );

                const combined = new Uint8Array(iv.length + encrypted.byteLength);
                combined.set(iv, 0);
                combined.set(new Uint8Array(encrypted), iv.length);

                return btoa(String.fromCharCode(...combined));
            } catch (error) {
                return null;
            }
        }

        async function generateRoomKey() {
            try {
                const key = await crypto.subtle.generateKey(
                    { name: "AES-GCM", length: 256 },
                    true,
                    ["encrypt", "decrypt"]
                );
                return key;
            } catch (error) {
                return null;
            }
        }

        async function exportKey(key) {
            try {
                const exported = await crypto.subtle.exportKey("jwk", key);
                return exported;
            } catch (error) {
                return null;
            }
        }

        async function importKey(jwk) {
            try {
                return await crypto.subtle.importKey(
                    "jwk",
                    jwk,
                    { name: "AES-GCM", length: 256 },
                    true,
                    ["encrypt", "decrypt"]
                );
            } catch (error) {
                return null;
            }
        }

        async function encryptMessage(message) {
            try {
                if (!roomKey) return null;

                const encoder = new TextEncoder();
                const encoded = encoder.encode(message);
                
                const iv = crypto.getRandomValues(new Uint8Array(12));
                
                const encrypted = await crypto.subtle.encrypt(
                    { name: "AES-GCM", iv: iv },
                    roomKey,
                    encoded
                );

                const combined = new Uint8Array(iv.length + encrypted.byteLength);
                combined.set(iv, 0);
                combined.set(new Uint8Array(encrypted), iv.length);

                return btoa(String.fromCharCode(...combined));
            } catch (error) {
                return null;
            }
        }

        async function decryptMessage(encryptedData) {
            try {
                if (!roomKey) return null;

                const combined = Uint8Array.from(atob(encryptedData), c => c.charCodeAt(0));
                
                const iv = combined.slice(0, 12);
                const encrypted = combined.slice(12);
                
                const decrypted = await crypto.subtle.decrypt(
                    { name: "AES-GCM", iv: iv },
                    roomKey,
                    encrypted
                );

                const decoder = new TextDecoder();
                return decoder.decode(decrypted);
            } catch (error) {
                return null;
            }
        }

        function setUsername() {
            const usernameInput = document.getElementById('usernameInput');
            const randomName = userNames[Math.floor(Math.random() * userNames.length)] + '_' + (Math.floor(Math.random() * 99) + 1);
            myUsername = usernameInput.value.trim() || randomName;
            userUID = generateRandomUserID();
        }

        function generateRoomId() {
            return Math.random().toString(36).substring(2, 8).toUpperCase();
        }

        async function checkRoomExists(roomId) {
            const database = firebase.database();
            const roomRef = database.ref('rooms/' + roomId);
            const snapshot = await roomRef.once('value');
            return snapshot.exists();
        }

        async function createRoom() {
            setUsername();
            if (!await ensureAuthentication()) return;
            
            let roomId = generateRoomId();
            let attempts = 0;
            
            while (await checkRoomExists(roomId) && attempts < 5) {
                roomId = generateRoomId();
                attempts++;
            }
            
            if (attempts >= 5) {
                alert('Unable to create unique room. Please try again.');
                return;
            }
            
            roomKey = await generateRoomKey();
            if (!roomKey) {
                alert('Failed to generate encryption key');
                return;
            }
            
            const exportedKey = await exportKey(roomKey);
            
            currentRoom = roomId;
            document.getElementById('roomCodeDisplay').textContent = currentRoom;
            document.getElementById('sessionCreated').classList.remove('hidden');
            document.getElementById('joinForm').classList.add('hidden');
            
            const database = firebase.database();
            const roomSetupRef = database.ref('rooms/' + currentRoom);
            await roomSetupRef.child('roomKey').set(exportedKey);
            await roomSetupRef.child('createdAt').set(Date.now());
        }

        function showJoinForm() {
            setUsername();
            document.getElementById('joinForm').classList.remove('hidden');
        }

        async function joinRoom() {
            setUsername();
            const roomCode = document.getElementById('roomCodeInput').value.trim().toUpperCase();
            
            if (roomCode.length === 6) {
                if (!await ensureAuthentication()) return;
                
                const database = firebase.database();
                const checkRoom = database.ref('rooms/' + roomCode);
                const snapshot = await checkRoom.once('value');
                
                if (!snapshot.exists()) {
                    alert('Secure channel does not exist');
                    return;
                }
                
                const roomData = snapshot.val();
                if (roomData.roomKey) {
                    roomKey = await importKey(roomData.roomKey);
                }
                
                currentRoom = roomCode;
                enterChat();
            } else {
                alert('Please enter a valid 6-digit access code');
            }
        }

        function copyRoomCode() {
            navigator.clipboard.writeText(currentRoom);
            alert('Access code copied to clipboard');
        }

        function enterChat() {
            document.getElementById('accessScreen').style.display = 'none';
            document.getElementById('chatScreen').style.display = 'flex';
            document.getElementById('currentRoomCode').textContent = currentRoom;
            
            document.getElementById('chatMessages').innerHTML = '';
            
            addSystemMessage('Secure connection established');
            addSystemMessage('Channel will close when all users disconnect');
            
            startFirebaseConnection();
            
            setTimeout(forceUsersSync, 1000);
            setTimeout(forceUsersSync, 3000);
        }

        function forceUsersSync() {
            if (usersRef) {
                usersRef.once('value').then(async (snapshot) => {
                    const users = snapshot.val() || {};
                    scheduleUsersUpdate(users);
                });
            }
        }

        function startHeartbeat() {
            if (heartbeatInterval) {
                clearInterval(heartbeatInterval);
            }
            
            heartbeatInterval = setInterval(() => {
                if (usersRef && userUID) {
                    usersRef.child(userUID).update({
                        lastSeen: Date.now()
                    });
                }
            }, 5000);
        }

        function stopFirebaseListeners() {
            if (usersListener) {
                usersRef.off('value', usersListener);
                usersListener = null;
            }
            if (messageListener) {
                messagesRef.off('child_added', messageListener);
                messageListener = null;
            }
            if (destroyListener && roomRef) {
                roomRef.child('destroySignal').off('value', destroyListener);
                destroyListener = null;
            }
            if (roomRef) {
                roomRef.off();
            }
        }

        function startFirebaseConnection() {
            stopFirebaseListeners();
            
            const database = firebase.database();
            roomRef = database.ref('rooms/' + currentRoom);
            usersRef = roomRef.child('users');
            messagesRef = roomRef.child('messages');
            
            roomRef.child('createdAt').set(Date.now());
            
            const registerUser = async () => {
                const userData = {
                    lastSeen: Date.now(),
                    registeredAt: Date.now()
                };
                
                const encryptedUsername = await encryptMessage(myUsername);
                if (encryptedUsername) {
                    userData.encryptedUsername = encryptedUsername;
                }
                
                const userRef = usersRef.child(userUID);
                await userRef.set(userData);
                userRef.onDisconnect().remove();
            };
            
            registerUser();
            
            usersListener = usersRef.on('value', async (snapshot) => {
                const users = snapshot.val() || {};
                scheduleUsersUpdate(users);
            });
            
            messageListener = messagesRef.limitToLast(50).on('child_added', async (snapshot) => {
                const message = snapshot.val();
                if (message.userId !== userUID) {
                    const decryptedContent = await decryptMessage(message.encryptedContent);
                    let decryptedUsername = 'anonymous';
                    
                    if (message.encryptedUsername) {
                        decryptedUsername = await decryptMessage(message.encryptedUsername) || 'anonymous';
                    }
                    
                    if (decryptedContent) {
                        addMessageWithDecryptAnimation(decryptedContent, decryptedUsername, false, message.timestamp);
                    }
                }
            });

            destroyListener = roomRef.child('destroySignal').on('value', (snapshot) => {
                if (snapshot.exists() && !disconnectAnimationShown) {
                    const destroyData = snapshot.val();
                    if (destroyData.timestamp && destroyData.initiator !== userUID) {
                        showDestroyAnimation();
                        setTimeout(() => {
                            destroyChat();
                        }, 100);
                    }
                }
            });

            roomRef.on('value', (snapshot) => {
                if (!snapshot.exists() && !disconnectAnimationShown) {
                    showDestroyAnimation();
                }
            });

            startHeartbeat();
            startPeriodicRoomCheck();
            
            if (syncInterval) {
                clearInterval(syncInterval);
            }
            syncInterval = setInterval(forceUsersSync, 3000);
        }

        function scheduleUsersUpdate(users) {
            if (usersUpdateTimeout) {
                clearTimeout(usersUpdateTimeout);
            }
            usersUpdateTimeout = setTimeout(() => {
                updateUsersList(users);
            }, 500);
        }

        function startPeriodicRoomCheck() {
            if (roomCheckInterval) {
                clearInterval(roomCheckInterval);
            }
            
            roomCheckInterval = setInterval(() => {
                checkAndDeleteEmptyRoom();
            }, 5000);
        }

        async function checkAndDeleteEmptyRoom() {
            if (!roomRef) return;
            
            try {
                const usersSnapshot = await usersRef.once('value');
                const users = usersSnapshot.val() || {};
                
                if (Object.keys(users).length === 0) {
                    await roomRef.remove();
                    if (roomCheckInterval) {
                        clearInterval(roomCheckInterval);
                    }
                }
            } catch (error) {
            }
        }

        async function updateUsersList(users) {
            const usersList = document.getElementById('usersList');
            usersList.innerHTML = '';
            
            const now = Date.now();
            const timeout = 30000;
            
            const tempUsers = [];
            const seenUserIds = new Set();
            
            for (const userId in users) {
                if (seenUserIds.has(userId)) continue;
                seenUserIds.add(userId);
                
                const user = users[userId];
                
                if ((now - user.lastSeen) > timeout && userId !== userUID) {
                    continue;
                }
                
                let username = 'anonymous';
                
                if (user.encryptedUsername) {
                    try {
                        username = await decryptMessage(user.encryptedUsername) || 'anonymous';
                    } catch (e) {
                        username = 'anonymous';
                    }
                }
                
                tempUsers.push({
                    id: userId,
                    username: username,
                    lastSeen: user.lastSeen || now,
                    isCurrent: userId === userUID
                });
            }
            
            const activeUsers = tempUsers.filter(user => {
                return (now - user.lastSeen) <= timeout || user.isCurrent;
            });
            
            const uniqueUsers = activeUsers.filter((user, index, self) => 
                index === self.findIndex(u => u.id === user.id)
            );
            
            const sortedUsers = uniqueUsers.sort((a, b) => {
                if (a.isCurrent) return -1;
                if (b.isCurrent) return 1;
                return a.username.localeCompare(b.username);
            });
            
            sortedUsers.forEach(user => {
                const userTag = document.createElement('div');
                userTag.className = 'user-tag';
                userTag.textContent = user.username;
                
                if (user.isCurrent) {
                    userTag.style.borderColor = 'var(--neon-blue)';
                    userTag.style.background = 'rgba(0, 247, 255, 0.1)';
                }
                
                usersList.appendChild(userTag);
            });
        }

        async function sendMessage() {
            const input = document.getElementById('messageInput');
            const message = input.value.trim();
            
            if (!message) return;
            
            const encryptedContent = await encryptMessage(message);
            const encryptedUsername = await encryptMessage(myUsername);
            
            if (!encryptedContent || !encryptedUsername) {
                alert('Encryption failed');
                return;
            }
            
            const messageData = {
                encryptedContent: encryptedContent,
                encryptedUsername: encryptedUsername,
                userId: userUID,
                timestamp: Date.now()
            };
            
            messagesRef.push(messageData);
            
            addMessageWithDecryptAnimation(message, myUsername, true, messageData.timestamp);
            input.value = '';
            input.focus();
        }

        function generateRandomChars(length) {
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*';
            let result = '';
            for (let i = 0; i < length; i++) {
                result += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return result;
        }

        function addMessageWithDecryptAnimation(content, username, isMe, timestamp) {
            const messagesContainer = document.getElementById('chatMessages');
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${isMe ? 'outgoing' : 'incoming'}`;
            
            const time = new Date(timestamp).toLocaleTimeString('ru-RU', { hour: '2-digit', minute: '2-digit' });
            const messageId = 'msg-' + timestamp + '-' + Math.random().toString(36).substr(2, 9);
            
            messageDiv.innerHTML = `
                <div class="message-header">
                    <span class="message-sender">${username}</span>
                    <span class="message-time">${time}</span>
                </div>
                <div class="message-content">
                    <span class="decrypting-text" id="${messageId}">${generateRandomChars(content.length)}</span>
                </div>
            `;
            
            messagesContainer.appendChild(messageDiv);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
            
            const decryptElement = document.getElementById(messageId);
            decryptText(decryptElement, content, 0, 50);
        }

        function decryptText(element, targetText, currentIndex, speed) {
            if (currentIndex >= targetText.length) {
                element.innerHTML = targetText;
                return;
            }

            const currentText = targetText.substring(0, currentIndex + 1);
            const remainingLength = targetText.length - currentIndex - 1;
            const randomChars = generateRandomChars(remainingLength);
            
            element.innerHTML = currentText + `<span class="decrypting-char">${randomChars}</span>`;
            
            setTimeout(() => {
                decryptText(element, targetText, currentIndex + 1, speed);
            }, speed);
        }

        function addSystemMessage(content) {
            const messagesContainer = document.getElementById('chatMessages');
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message system';
            messageDiv.innerHTML = `<div class="message-content">[SYSTEM] ${content}</div>`;
            
            messagesContainer.appendChild(messageDiv);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

        function showDestroyAnimation() {
            if (disconnectAnimationShown) return;
            
            const overlay = document.createElement('div');
            overlay.className = 'destroy-overlay';
            document.body.appendChild(overlay);
            
            const glitch = document.createElement('div');
            glitch.className = 'destroy-glitch';
            document.body.appendChild(glitch);
            
            const staticEffect = document.createElement('div');
            staticEffect.className = 'destroy-static';
            document.body.appendChild(staticEffect);
            
            const text = document.createElement('div');
            text.className = 'destroy-text';
            text.textContent = 'CONNECTION TERMINATED';
            document.body.appendChild(text);
            
            overlay.style.animation = 'destroyOverlay 1.5s ease-in-out forwards';
            glitch.style.animation = 'destroyGlitch 1.5s ease-in-out';
            staticEffect.style.animation = 'destroyStatic 1.5s ease-in-out';
            text.style.animation = 'destroyText 1.5s ease-in-out';
            
            setTimeout(() => {
                overlay.remove();
                glitch.remove();
                staticEffect.remove();
                text.remove();
                resetToMainScreen();
            }, 1500);
        }

        async function destroyChat() {
            if (!roomRef || disconnectAnimationShown) return;
            
            showDestroyAnimation();
            disconnectAnimationShown = true;
            
            await roomRef.child('destroySignal').set({
                timestamp: Date.now(),
                initiator: userUID
            });
            
            stopFirebaseListeners();
            
            if (roomCheckInterval) {
                clearInterval(roomCheckInterval);
                roomCheckInterval = null;
            }
            
            if (heartbeatInterval) {
                clearInterval(heartbeatInterval);
                heartbeatInterval = null;
            }
            
            if (syncInterval) {
                clearInterval(syncInterval);
                syncInterval = null;
            }
            
            if (usersUpdateTimeout) {
                clearTimeout(usersUpdateTimeout);
                usersUpdateTimeout = null;
            }
            
            try {
                if (usersRef && userUID) {
                    await usersRef.child(userUID).remove();
                }
                
                await roomRef.remove();
                
            } catch (error) {
            }
        }

        function resetToMainScreen() {
            stopFirebaseListeners();
            
            if (roomCheckInterval) clearInterval(roomCheckInterval);
            if (heartbeatInterval) clearInterval(heartbeatInterval);
            if (syncInterval) clearInterval(syncInterval);
            if (usersUpdateTimeout) clearTimeout(usersUpdateTimeout);
            
            currentRoom = null;
            roomRef = null;
            usersRef = null;
            messagesRef = null;
            roomKey = null;
            
            document.getElementById('chatScreen').style.display = 'none';
            document.getElementById('accessScreen').style.display = 'block';
            document.getElementById('sessionCreated').classList.add('hidden');
            document.getElementById('joinForm').classList.add('hidden');
            document.getElementById('chatMessages').innerHTML = '';
            
            disconnectAnimationShown = false;
        }

        document.addEventListener('DOMContentLoaded', function() {
            userUID = generateRandomUserID();
            
            document.getElementById('createRoomBtn').addEventListener('click', createRoom);
            document.getElementById('showJoinFormBtn').addEventListener('click', showJoinForm);
            document.getElementById('joinRoomBtn').addEventListener('click', joinRoom);
            document.getElementById('copyRoomCodeBtn').addEventListener('click', copyRoomCode);
            document.getElementById('enterChatBtn').addEventListener('click', enterChat);
            document.getElementById('sendMessageBtn').addEventListener('click', sendMessage);
            document.getElementById('destroyChatBtn').addEventListener('click', destroyChat);
            document.getElementById('deleteDecoyRoomsBtn').addEventListener('click', deleteDecoyRooms);
            document.getElementById('createFakeRoomsBtn').addEventListener('click', createFakeRooms);
            document.getElementById('deleteEmptyRoomsBtn').addEventListener('click', deleteEmptyRooms);

            document.getElementById('messageInput').addEventListener('keydown', function(e) {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    sendMessage();
                }
            });

            document.getElementById('roomCodeInput').addEventListener('keydown', function(e) {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    joinRoom();
                }
            });

            document.getElementById('usernameInput').addEventListener('keydown', function(e) {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    document.getElementById('roomCodeInput').focus();
                }
            });
        });

        window.addEventListener('beforeunload', () => {
            if (matrixAnimationId) {
                cancelAnimationFrame(matrixAnimationId);
            }
            
            if (roomCheckInterval) {
                clearInterval(roomCheckInterval);
            }
            
            if (heartbeatInterval) {
                clearInterval(heartbeatInterval);
            }
            
            if (syncInterval) {
                clearInterval(syncInterval);
            }
            
            if (usersUpdateTimeout) {
                clearTimeout(usersUpdateTimeout);
            }
            
            if (decoyRoomManager.maintenanceInterval) {
                clearInterval(decoyRoomManager.maintenanceInterval);
            }
            
            stopAllNodes();
            
            if (usersRef && userUID) {
                usersRef.child(userUID).remove();
            }
        });

        window.addEventListener('load', () => {
            initMatrixRain();
            
            setTimeout(() => {
                document.getElementById('loadingScreen').style.display = 'none';
            }, 3500);
        });

        window.addEventListener('resize', initMatrixRain);

        document.addEventListener('touchstart', function() {}, {passive: true});
    </script>
</body>
</html>